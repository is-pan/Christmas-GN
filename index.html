<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grand Luxury Tree Final v2</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000000;
        font-family: 'Times New Roman', serif;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      /* UI Overlay - Minimalist */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-top: 40px;
        box-sizing: border-box;
        /* Remove transition here as we don't hide the whole layer anymore */
      }

      /* When hidden class is applied to specific elements */
      .ui-hidden {
        opacity: 0;
        pointer-events: none !important;
      }

      /* Loading */
      #loader {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.8s ease-out;
      }
      .loader-text {
        color: #d4af37;
        font-size: 14px;
        letter-spacing: 4px;
        margin-top: 20px;
        text-transform: uppercase;
        font-weight: 100;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 1px solid rgba(212, 175, 55, 0.2);
        border-top: 1px solid #d4af37;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Typography - Centerpiece */
      h1 {
        color: #fceea7;
        font-size: 56px;
        margin: 0;
        font-weight: 400;
        letter-spacing: 6px;
        text-shadow: 0 0 50px rgba(252, 238, 167, 0.6);
        background: linear-gradient(to bottom, #fff, #eebb66);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-family: 'Cinzel', 'Times New Roman', serif;
        opacity: 0.9;
        transition: opacity 0.5s ease; /* Ensure smooth transitions if needed */
      }

      /* Upload Button - Restored & Elegant */
      .upload-wrapper {
        position: absolute;
        top: 40px;
        right: 40px;
        pointer-events: auto;
        text-align: center;
        transition: opacity 0.5s ease; /* Add transition for smooth hiding */
      }
      .upload-btn {
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid rgba(212, 175, 55, 0.4);
        color: #d4af37;
        padding: 10px 25px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 3px;
        font-size: 10px;
        transition: all 0.4s;
        display: inline-block;
        backdrop-filter: blur(5px);
      }
      .upload-btn:hover {
        background: #d4af37;
        color: #000;
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
      }
      .hint-text {
        color: rgba(212, 175, 55, 0.5);
        font-size: 9px;
        margin-top: 8px;
        letter-spacing: 1px;
        text-transform: uppercase;
      }

      #file-input {
        display: none;
      }

      /* Webcam feedback */
      #webcam-wrapper {
        position: absolute;
        bottom: 40px;
        right: 40px;
        width: 160px;
        height: 120px;
        border: 2px solid rgba(212, 175, 55, 0.6);
        border-radius: 4px;
        overflow: hidden;
        opacity: 1;
        pointer-events: none;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        z-index: 50;
      }

      #webcam-preview {
        width: 100%;
        height: 100%;
        display: block;
      }

      @media (orientation: portrait) and (max-width: 900px) {
        #webcam-wrapper {
          width: clamp(104px, 24vw, 128px);
          height: auto;
          aspect-ratio: 4 / 3;
          bottom: 24px;
          right: 24px;
        }
      }

      /* Â∏ÆÂä©Èù¢Êùø - Â∑¶‰æß */
      #help-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid rgba(212, 175, 55, 0.4);
        border-radius: 8px;
        padding: 20px;
        max-width: 280px;
        pointer-events: auto;
        font-size: 13px;
        line-height: 1.6;
        transition: opacity 0.5s ease;
      }

      #help-panel h3 {
        color: #d4af37;
        margin: 0 0 15px 0;
        border-bottom: 1px solid #d4af37;
        padding-bottom: 10px;
        font-size: 16px;
      }

      #help-panel p {
        margin: 8px 0;
        color: #ccc;
      }

      #help-panel code {
        background: rgba(212, 175, 55, 0.15);
        padding: 2px 6px;
        border-radius: 3px;
        color: #d4af37;
        font-family: monospace;
      }

      #help-panel hr {
        border: none;
        border-top: 1px solid #d4af37;
        margin: 12px 0;
      }

      /* UIÈöêËóèÁ±ª */
      .ui-hidden #help-panel,
      .ui-hidden .upload-wrapper {
        opacity: 0;
        pointer-events: none;
      }

      #webcam-wrapper.ui-hidden {
        opacity: 0;
        pointer-events: none !important;
      }

      /* Settings menu */
      #settings-wrapper {
        position: absolute;
        top: 40px;
        right: 40px;
        pointer-events: auto;
        z-index: 60;
      }

      .ui-hidden #settings-wrapper {
        opacity: 0;
        pointer-events: none !important;
      }

      #settings-btn {
        width: 38px;
        height: 32px;
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid rgba(212, 175, 55, 0.4);
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        transition: all 0.25s;
      }

      #settings-btn:hover {
        background: rgba(212, 175, 55, 0.18);
        box-shadow: 0 0 18px rgba(212, 175, 55, 0.25);
      }

      #mode-toggle-btn {
        margin-top: 10px;
        width: 38px;
        height: 28px;
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid rgba(212, 175, 55, 0.4);
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        transition: all 0.25s;
        color: rgba(212, 175, 55, 0.95);
        font-size: 14px;
        letter-spacing: 0px;
        user-select: none;
      }

      #mode-toggle-btn:hover {
        background: rgba(212, 175, 55, 0.18);
        box-shadow: 0 0 18px rgba(212, 175, 55, 0.25);
      }

      .hamburger {
        width: 18px;
        height: 12px;
        position: relative;
      }
      .hamburger::before,
      .hamburger::after,
      .hamburger span {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        height: 2px;
        background: rgba(212, 175, 55, 0.9);
        border-radius: 2px;
      }
      .hamburger::before {
        top: 0;
      }
      .hamburger span {
        top: 5px;
      }
      .hamburger::after {
        bottom: 0;
      }

      #settings-panel {
        position: absolute;
        top: 44px;
        right: 0;
        width: 300px;
        background: rgba(0, 0, 0, 0.86);
        border: 1px solid rgba(212, 175, 55, 0.4);
        border-radius: 10px;
        padding: 14px 14px 12px;
        box-sizing: border-box;
        backdrop-filter: blur(6px);
      }

      #settings-panel.hidden {
        display: none;
      }

      .menu-title {
        color: #d4af37;
        font-size: 12px;
        letter-spacing: 2px;
        text-transform: uppercase;
        margin: 6px 0 10px;
      }

      .menu-btn {
        width: 100%;
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid rgba(212, 175, 55, 0.35);
        color: #d4af37;
        padding: 10px 12px;
        cursor: pointer;
        letter-spacing: 2px;
        font-size: 11px;
        transition: all 0.25s;
        display: block;
        text-align: left;
      }

      .menu-btn:hover {
        background: rgba(212, 175, 55, 0.16);
        box-shadow: 0 0 14px rgba(212, 175, 55, 0.18);
      }

      .menu-sep {
        border: none;
        border-top: 1px solid rgba(212, 175, 55, 0.25);
        margin: 12px 0;
      }

      .menu-help p {
        margin: 8px 0;
        color: #ccc;
        font-size: 12px;
        line-height: 1.6;
      }

      .menu-help code {
        background: rgba(212, 175, 55, 0.15);
        padding: 2px 6px;
        border-radius: 3px;
        color: #d4af37;
        font-family: monospace;
      }

      .menu-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
        color: #ccc;
        font-size: 12px;
        letter-spacing: 1px;
        user-select: none;
      }

      .menu-toggle input {
        accent-color: #d4af37;
      }

      .menu-select {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-top: 10px;
        color: #ccc;
        font-size: 12px;
        letter-spacing: 1px;
        user-select: none;
      }

      .menu-select select {
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid rgba(212, 175, 55, 0.35);
        color: #d4af37;
        padding: 6px 8px;
        border-radius: 6px;
        font-size: 12px;
        outline: none;
      }
      
      #menu-hide-ui-btn {
        margin-top: 14px;
      }

      /* ÂõæÁâáÁÆ°ÁêÜÊåâÈíÆ - Â∑¶‰∏ãËßí */
      #manage-photos-btn {
        position: absolute;
        bottom: 40px;
        left: 40px;
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid rgba(212, 175, 55, 0.4);
        color: #d4af37;
        padding: 10px 25px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 3px;
        font-size: 10px;
        transition: all 0.4s;
        display: inline-block;
        backdrop-filter: blur(5px);
        pointer-events: auto;
      }
      
      #manage-photos-btn:hover {
        background: #d4af37;
        color: #000;
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
      }

      /* ÂõæÁâáÁÆ°ÁêÜÈù¢Êùø */
      #photo-manager {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
      }

      #photo-manager.hidden {
        display: none;
      }

      #manager-header {
        color: #d4af37;
        font-size: 24px;
        margin-bottom: 30px;
        text-align: center;
        font-family: 'Cinzel', 'Times New Roman', serif;
      }

      #photo-grid {
        display: grid;
        grid-template-columns: repeat(4, 150px);
        gap: 20px;
        max-width: 700px;
        max-height: 70vh;
        overflow-y: auto;
        padding: 20px;
      }

      .photo-item {
        position: relative;
        width: 150px;
        height: 150px;
        border: 2px solid #d4af37;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .photo-item img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
      }

      .delete-btn {
        position: absolute;
        top: -10px;
        right: -10px;
        width: 24px;
        height: 24px;
        background: #cc0000;
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        border: 2px solid #000;
        z-index: 1001;
      }

      #close-manager {
        margin-top: 30px;
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid rgba(212, 175, 55, 0.4);
        color: #d4af37;
        padding: 10px 25px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 3px;
        font-size: 10px;
        transition: all 0.4s;
        backdrop-filter: blur(5px);
      }

      #close-manager:hover {
        background: #d4af37;
        color: #000;
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
      }
    </style>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
      }
    </script>
  </head>
  <body>
    <div id="loader">
      <div class="spinner"></div>
      <div class="loader-text">Loading Holiday Magic</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
      <h1>Merry Christmas</h1>
      <div id="settings-wrapper">
        <button id="settings-btn" aria-label="ËÆæÁΩÆ">
          <div class="hamburger"><span></span></div>
        </button>
        <button id="mode-toggle-btn" aria-label="ÂàáÊç¢Ê®°Âºè">‚áÑ</button>
        <div id="settings-panel" class="hidden">
          <div class="menu-title">ËÆæÁΩÆ</div>
          <button id="menu-upload-btn" class="menu-btn">‰∏ä‰º†ÁÖßÁâá</button>
          <input type="file" id="file-input" multiple accept="image/*" />
          <button id="menu-manage-btn" class="menu-btn">ÁÆ°ÁêÜÁÖßÁâá</button>
          <hr class="menu-sep" />
          <div class="menu-title">ÊéßÂà∂ËØ¥Êòé</div>
          <div class="menu-help">
            <p><code>üëä</code> <b>Êè°Êã≥</b>ÔºöËÅöÂêàÊ†ëÂΩ¢</p>
            <p><code>üñêÔ∏è</code> <b>Âº†ÂºÄ</b>ÔºöÁ≤íÂ≠êÊï£ÂºÄ</p>
            <p><code>ü§è</code> <b>ÊçèÂ§π</b>ÔºöÁÖßÁâáËÅöÁÑ¶</p>
          </div>
          <label class="menu-toggle">
            <input id="toggle-skeleton" type="checkbox" checked />
            ÊòæÁ§∫È™®È™º
          </label>
          <div class="menu-select">
            <span>ÊâãÂäøÁÅµÊïèÂ∫¶</span>
            <select id="gesture-sensitivity">
              <option value="slow">ÊÖ¢</option>
              <option value="medium" selected>‰∏≠</option>
              <option value="fast">Âø´</option>
            </select>
          </div>
          <button id="menu-hide-ui-btn" class="menu-btn">ÈöêËóèUI</button>
        </div>
      </div>
    </div>

    <!-- ÂõæÁâáÁÆ°ÁêÜÈù¢Êùø -->
    <div id="photo-manager" class="hidden">
      <h2 id="manager-header">ÁÖßÁâáÁÆ°ÁêÜ</h2>
      <div id="photo-grid"></div>
      <button id="close-manager">ÂÖ≥Èó≠ÁÆ°ÁêÜÂô®</button>
    </div>

    <!-- Webcam hidden structure -->
    <div id="webcam-wrapper">
      <video id="webcam" autoplay muted playsinline style="display: none"></video>
      <canvas id="webcam-preview"></canvas>
    </div>

    <script type="module">
      import * as THREE from 'three'
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
      import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js'
      import { RenderPass } from 'three/addons/postprocessing/RenderPass.js'
      import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js'
      import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'
      import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision'

      // --- CONFIGURATION ---
      const CONFIG = {
        colors: {
          bg: 0x000000,
          champagneGold: 0xffd966,
          deepGreen: 0x03180a,
          accentRed: 0x990000,
        },
        particles: {
          count: 1500,
          dustCount: 2500,
          treeHeight: 24,
          treeRadius: 8,
        },
        camera: {
          z: 50,
        },
      }

      const STAR_MATERIAL_PARAMS = {
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 2.4,
        metalness: 0.0,
        roughness: 0.22,
        clearcoat: 1.0,
        clearcoatRoughness: 0.06,
      }

      const STATE = {
        mode: 'TREE',
        focusIndex: -1,
        focusTarget: null,
        gestureSensitivity: 'medium',
        hand: { detected: false, x: 0, y: 0, landmarks: null, showSkeleton: true, lastSeenMs: 0 },
        gesture: { lastUpdateMs: 0, lastSwitchMs: 0, fistMs: 0, pinchMs: 0, openMs: 0 },
        drag: {
          active: false,
          pointerId: null,
          lastSeenMs: 0,
          lastMoveMs: 0,
          startX: 0,
          startY: 0,
          lastX: 0,
          lastY: 0,
          moved: false,
          vx: 0,
          vy: 0,
          tapActive: false,
          tapPhoto: null,
        },
        rotation: { x: 0, y: 0 },
        uiHidden: false,
        intro: { phase: 'BOX', startMs: 0, emitT: 0, particlesVisible: false },
      }

      let scene, camera, renderer, composer
      let mainGroup
      let clock = new THREE.Clock()
      let particleSystem = []
      let photoMeshGroup = new THREE.Group()
      let modeToggleBtn
      let handLandmarker, video, webcamCanvas, webcamCtx
      let caneTexture, snowflakeTexture
      let snowflakeSystem
      let ribbonSystem
      let starRig
      let occluder
      let giftBoxGroup
      let giftBoxLidPivot
      let giftBoxMaterials = []
      let giftBoxInnerLight
      let giftBoxGlow
      let giftSparkleRig
      let giftBoxBaseScale = 1.85
      const _giftBoxBasePos = new THREE.Vector3()
      const _giftTmp = new THREE.Vector3()
      const _introEmitFrom = new THREE.Vector3()
      const _photoRaycaster = new THREE.Raycaster()
      const _photoNdc = new THREE.Vector2()

      const clamp01 = (v) => Math.min(1, Math.max(0, v))
      const easeOutCubic = (t) => 1 - Math.pow(1 - clamp01(t), 3)
      const easeInOutCubic = (t) => {
        const x = clamp01(t)
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2
      }
      const smoothstep = (edge0, edge1, x) => {
        const t = clamp01((x - edge0) / (edge1 - edge0))
        return t * t * (3 - 2 * t)
      }

      const getViewportProfile = () => {
        const w = window.innerWidth || 1
        const h = window.innerHeight || 1
        const aspect = w / h
        const portrait = h > w && aspect < 0.85
        const compact = Math.min(w, h) < 520
        return { w, h, aspect, portrait, compact }
      }

      const applyResponsiveLayout = () => {
        if (!camera) return
        const vp = getViewportProfile()
        const introActive = STATE.intro && STATE.intro.phase !== 'DONE'
        const mode = introActive ? 'TREE' : STATE.mode

        let fov = 42
        let camZ = CONFIG.camera.z
        let camY = 2

        if (vp.portrait) {
          fov = vp.compact ? 56 : 52
          camY = 1.8
          camZ = mode === 'SCATTER' ? (vp.compact ? 82 : 77) : mode === 'FOCUS' ? (vp.compact ? 74 : 71) : vp.compact ? 71 : 68
          if (vp.compact) camZ += 2
        }

        if (vp.portrait && (mode === 'SCATTER' || mode === 'FOCUS')) {
          const photoCount = particleSystem ? particleSystem.filter((p) => p.type === 'PHOTO').length : 0
          const extra = Math.max(0, photoCount - 24)
          if (extra > 0) {
            const scale = vp.portrait ? (mode === 'SCATTER' ? 0.6 : 0.35) : mode === 'SCATTER' ? 0.45 : 0.25
            const cap = vp.portrait ? (mode === 'SCATTER' ? 22 : 12) : mode === 'SCATTER' ? 18 : 10
            camZ += Math.min(cap, extra * scale)
          }
        }

        camera.fov = fov
        camera.aspect = vp.w / vp.h
        camera.position.set(0, camY, camZ)
        camera.updateProjectionMatrix()

        if (giftBoxGroup) {
          giftBoxBaseScale = vp.portrait ? (vp.compact ? 1.24 : 1.42) : 1.85
          giftBoxGroup.position.set(0, vp.portrait ? (vp.compact ? -8.15 : -7.9) : -7.2, vp.portrait ? (vp.compact ? 19.5 : 19) : 18)
          _giftBoxBasePos.copy(giftBoxGroup.position)
          giftBoxGroup.scale.setScalar(giftBoxBaseScale)
        }
      }

      const PHOTO_STORE = {
        db: null,
        opening: null,
      }

      const openPhotoDb = () => {
        if (PHOTO_STORE.db) return Promise.resolve(PHOTO_STORE.db)
        if (PHOTO_STORE.opening) return PHOTO_STORE.opening
        PHOTO_STORE.opening = new Promise((resolve, reject) => {
          const req = indexedDB.open('ChristmasTreePhotosDB', 1)
          req.onupgradeneeded = () => {
            const db = req.result
            if (!db.objectStoreNames.contains('photos')) {
              db.createObjectStore('photos', { keyPath: 'id', autoIncrement: true })
            }
          }
          req.onsuccess = () => {
            PHOTO_STORE.db = req.result
            PHOTO_STORE.opening = null
            resolve(PHOTO_STORE.db)
          }
          req.onerror = () => {
            PHOTO_STORE.opening = null
            reject(req.error)
          }
        })
        return PHOTO_STORE.opening
      }

      const reqToPromise = (req) =>
        new Promise((resolve, reject) => {
          req.onsuccess = () => resolve(req.result)
          req.onerror = () => reject(req.error)
        })

      const txDone = (tx) =>
        new Promise((resolve, reject) => {
          tx.oncomplete = () => resolve()
          tx.onabort = () => reject(tx.error || new Error('Transaction aborted'))
          tx.onerror = () => reject(tx.error)
        })

      const savePhotoBlob = async (blob) => {
        const db = await openPhotoDb()
        const tx = db.transaction('photos', 'readwrite')
        const store = tx.objectStore('photos')
        const id = await reqToPromise(store.add({ blob, createdAt: Date.now() }))
        await txDone(tx)
        return id
      }

      const deletePhotoBlob = async (id) => {
        const db = await openPhotoDb()
        const tx = db.transaction('photos', 'readwrite')
        const store = tx.objectStore('photos')
        await reqToPromise(store.delete(id))
        await txDone(tx)
      }

      const loadAllPhotoBlobs = async () => {
        const db = await openPhotoDb()
        const tx = db.transaction('photos', 'readonly')
        const store = tx.objectStore('photos')
        const rows = await reqToPromise(store.getAll())
        await txDone(tx)
        return rows
      }

      const loadTextureFromUrl = (url) =>
        new Promise((resolve, reject) => {
          new THREE.TextureLoader().load(
            url,
            (t) => resolve(t),
            undefined,
            (err) => reject(err)
          )
        })

      const restoreSavedPhotos = async () => {
        let rows = []
        try {
          rows = await loadAllPhotoBlobs()
        } catch {
          return 0
        }
        rows.sort((a, b) => (a.id ?? 0) - (b.id ?? 0))
        let added = 0
        for (const row of rows) {
          const blob = row?.blob
          const id = row?.id
          if (!blob || typeof id !== 'number') continue
          const url = URL.createObjectURL(blob)
          try {
            const t = await loadTextureFromUrl(url)
            t.colorSpace = THREE.SRGBColorSpace
            addPhotoToScene(t, { photoId: id, objectUrl: url })
            added++
          } catch {
            try {
              URL.revokeObjectURL(url)
            } catch {}
          }
        }
        return added
      }

      function updateModeToggleBtn() {
        if (!modeToggleBtn) return
        modeToggleBtn.textContent = '‚áÑ'
      }

      function pickPhotoGroupAt(clientX, clientY) {
        if (!renderer || !camera || !photoMeshGroup) return null
        if (!photoMeshGroup.children.length) return null

        const rect = renderer.domElement.getBoundingClientRect()
        const x = ((clientX - rect.left) / rect.width) * 2 - 1
        const y = -(((clientY - rect.top) / rect.height) * 2 - 1)
        _photoNdc.set(x, y)
        _photoRaycaster.setFromCamera(_photoNdc, camera)

        const hits = _photoRaycaster.intersectObjects(photoMeshGroup.children, true)
        if (!hits.length) return null

        let obj = hits[0].object
        while (obj && obj.parent && obj.parent !== photoMeshGroup) obj = obj.parent
        if (obj && obj.parent === photoMeshGroup) return obj
        return null
      }

      function pickGiftBoxAt(clientX, clientY) {
        if (!renderer || !camera || !giftBoxGroup) return false
        if (!giftBoxGroup.visible) return false
        const rect = renderer.domElement.getBoundingClientRect()
        const x = ((clientX - rect.left) / rect.width) * 2 - 1
        const y = -(((clientY - rect.top) / rect.height) * 2 - 1)
        _photoNdc.set(x, y)
        _photoRaycaster.setFromCamera(_photoNdc, camera)
        const hits = _photoRaycaster.intersectObject(giftBoxGroup, true)
        return hits.length > 0
      }

      function setMode(nextMode) {
        if (STATE.intro && STATE.intro.phase !== 'DONE') return
        if (STATE.mode === nextMode) return
        STATE.mode = nextMode
        if (STATE.gesture) STATE.gesture.lastSwitchMs = performance.now()
        if (nextMode !== 'FOCUS') STATE.focusTarget = null
        updateModeToggleBtn()
        applyResponsiveLayout()
        if (nextMode === 'SCATTER' || nextMode === 'FOCUS') relayoutScatterPhotos()
      }

      function getGestureSensitivityConfig() {
        const v = STATE.gestureSensitivity || 'medium'
        if (v === 'fast') return { rot: 1.25, follow: 1.15, smooth: 0.3 }
        if (v === 'slow') return { rot: 0.85, follow: 0.85, smooth: 0.16 }
        return { rot: 1.0, follow: 1.0, smooth: 0.22 }
      }

      async function init() {
        initThree()
        applyResponsiveLayout()
        setupEnvironment()
        setupLights()
        createTextures()
        createParticles()
        createRibbon()
        createDust()
        const restored = await restoreSavedPhotos()
        if (!restored) createDefaultPhotos()
        createOccluder()
        createGiftBox()
        applyResponsiveLayout()
        setMainContentVisible(false)
        setupPostProcessing()
        setupEvents()
        await initMediaPipe()

        const loader = document.getElementById('loader')
        loader.style.opacity = 0
        setTimeout(() => loader.remove(), 800)

        animate()
      }

      function initThree() {
        const container = document.getElementById('canvas-container')
        scene = new THREE.Scene()
        scene.background = new THREE.Color(CONFIG.colors.bg)
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01)

        camera = new THREE.PerspectiveCamera(
          42,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        )
        camera.position.set(0, 2, CONFIG.camera.z)

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: 'high-performance',
        })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        renderer.toneMapping = THREE.ReinhardToneMapping
        renderer.toneMappingExposure = 2.2
        renderer.domElement.style.touchAction = 'none'
        container.appendChild(renderer.domElement)

        mainGroup = new THREE.Group()
        scene.add(mainGroup)
      }

      function setupEnvironment() {
        const pmremGenerator = new THREE.PMREMGenerator(renderer)
        scene.environment = pmremGenerator.fromScene(
          new RoomEnvironment(),
          0.04
        ).texture
      }

      function setupLights() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.6)
        scene.add(ambient)

        const innerLight = new THREE.PointLight(0xffaa00, 2, 20)
        innerLight.position.set(0, 5, 0)
        mainGroup.add(innerLight)

        const spotGold = new THREE.SpotLight(0xffcc66, 1200)
        spotGold.position.set(30, 40, 40)
        spotGold.angle = 0.5
        spotGold.penumbra = 0.5
        scene.add(spotGold)

        const spotBlue = new THREE.SpotLight(0x6688ff, 600)
        spotBlue.position.set(-30, 20, -30)
        scene.add(spotBlue)
      }

      function setupPostProcessing() {
        const renderScene = new RenderPass(scene, camera)
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        )
        bloomPass.threshold = 1.05
        bloomPass.strength = 0.45
        bloomPass.radius = 0.4

        composer = new EffectComposer(renderer)
        composer.addPass(renderScene)
        composer.addPass(bloomPass)
      }

      function createOccluder() {
        const baseW = CONFIG.particles.treeRadius * 2 * 1
        const h = CONFIG.particles.treeHeight * 1
        const halfH = h / 2

        const shape = new THREE.Shape()
        shape.moveTo(-baseW / 2, -halfH)
        shape.lineTo(0, halfH)
        shape.lineTo(baseW / 2, -halfH)
        shape.closePath()

        const geo = new THREE.ShapeGeometry(shape)
        const mat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide })
        occluder = new THREE.Mesh(geo, mat)
        occluder.position.set(0, 0, -0.25)
        occluder.frustumCulled = false
        scene.add(occluder)
      }

      function setMainContentVisible(visible) {
        particleSystem.forEach((p) => {
          if (p?.mesh) p.mesh.visible = visible
        })
        if (snowflakeSystem?.mesh) snowflakeSystem.mesh.visible = visible
        if (ribbonSystem?.mesh) ribbonSystem.mesh.visible = visible
        if (starRig?.group) starRig.group.visible = visible
        if (occluder) occluder.visible = false
        STATE.intro.particlesVisible = visible
      }

      function startIntroOpen() {
        if (!STATE.intro || STATE.intro.phase !== 'BOX') return
        STATE.intro.phase = 'OPENING'
        STATE.intro.startMs = performance.now()
        STATE.intro.emitT = 0
        STATE.intro.particlesVisible = false
      }

      function updateIntro(dt) {
        const intro = STATE.intro
        if (!intro || intro.phase === 'DONE') return

        if (intro.phase === 'BOX') {
          intro.emitT = 0
          if (giftBoxGroup) giftBoxGroup.visible = true
          if (giftBoxLidPivot) giftBoxLidPivot.rotation.x = 0
          giftBoxMaterials.forEach((m) => {
            m.transparent = true
            m.opacity = 1
          })
          if (giftBoxInnerLight) giftBoxInnerLight.intensity = 0
          if (giftBoxGlow?.material) {
            giftBoxGlow.material.transparent = true
            giftBoxGlow.material.opacity = 0.85
          }
          if (giftSparkleRig) {
            giftSparkleRig.points.visible = true
            giftSparkleRig.material.transparent = true
            giftSparkleRig.material.opacity = 1
          }
          if (giftBoxGroup) {
            const tt = clock.elapsedTime
            const bob = 0.32 * Math.sin(tt * 1.35)
            const sway = 0.14 * Math.sin(tt * 0.9)
            giftBoxGroup.position.copy(_giftBoxBasePos).add(_giftTmp.set(0, bob, 0))
            giftBoxGroup.rotation.y = sway
            giftBoxGroup.rotation.z = 0.035 * Math.sin(tt * 1.1)
            giftBoxGroup.scale.setScalar(giftBoxBaseScale * (1 + 0.02 * Math.sin(tt * 1.6)))
            _introEmitFrom.set(
              giftBoxGroup.position.x,
              giftBoxGroup.position.y + 4.2 * giftBoxGroup.scale.y * 0.58,
              giftBoxGroup.position.z + 6.2 * giftBoxGroup.scale.y * 0.05
            )
          }
          if (giftSparkleRig) {
            const tt = clock.elapsedTime
            const p = giftSparkleRig.positions
            for (let i = 0; i < giftSparkleRig.count; i++) {
              giftSparkleRig.angles[i] += giftSparkleRig.speeds[i] * dt
              giftSparkleRig.heights[i] += giftSparkleRig.rises[i] * dt
              if (giftSparkleRig.heights[i] > giftSparkleRig.maxH) {
                giftSparkleRig.heights[i] = giftSparkleRig.minH
                giftSparkleRig.angles[i] = Math.random() * Math.PI * 2
                giftSparkleRig.radii[i] =
                  giftSparkleRig.minR +
                  Math.random() * (giftSparkleRig.maxR - giftSparkleRig.minR)
              }
              const a = giftSparkleRig.angles[i]
              const r =
                giftSparkleRig.radii[i] +
                0.18 * Math.sin(tt * 1.3 + giftSparkleRig.phases[i])
              const y =
                giftSparkleRig.heights[i] +
                0.12 * Math.sin(tt * 2.2 + giftSparkleRig.phases[i])
              p[i * 3 + 0] = Math.cos(a) * r
              p[i * 3 + 1] = y
              p[i * 3 + 2] = Math.sin(a) * r
            }
            giftSparkleRig.geometry.attributes.position.needsUpdate = true
          }
          return
        }

        const now = performance.now()
        const t = clamp01((now - intro.startMs) / 5600)
        const openT = smoothstep(0.0, 0.35, t)
        intro.emitT = clamp01((t - 0.02) / 0.98)

        if (!intro.particlesVisible && intro.emitT > 0) {
          setMainContentVisible(true)
          particleSystem.forEach((p) => {
            if (p?.mesh) p.mesh.position.copy(_introEmitFrom)
          })
          if (snowflakeSystem?.items) {
            for (let i = 0; i < snowflakeSystem.items.length; i++) {
              snowflakeSystem.items[i].pos.copy(_introEmitFrom)
            }
          }
          if (ribbonSystem?.items) {
            for (let i = 0; i < ribbonSystem.items.length; i++) {
              ribbonSystem.items[i].pos.copy(_introEmitFrom)
            }
          }
        }

        if (giftBoxLidPivot) giftBoxLidPivot.rotation.x = -openT * Math.PI * 0.82

        const fadeT = smoothstep(0.06, 0.42, intro.emitT)
        const alpha = 1 - fadeT
        giftBoxMaterials.forEach((m) => {
          m.transparent = true
          m.opacity = alpha
        })
        if (giftBoxInnerLight) {
          const on = smoothstep(0.12, 0.28, intro.emitT)
          giftBoxInnerLight.intensity = 4.2 * on * alpha
        }
        if (giftBoxGlow?.material) {
          giftBoxGlow.material.transparent = true
          giftBoxGlow.material.opacity = 0.85 * alpha
        }
        if (giftSparkleRig) {
          giftSparkleRig.material.transparent = true
          giftSparkleRig.material.opacity = alpha
        }
        if (giftBoxGroup) {
          giftBoxGroup.visible = alpha > 0.01
          giftBoxGroup.scale.setScalar(giftBoxBaseScale * (1 - 0.08 * fadeT))
        }
        if (giftSparkleRig && giftBoxGroup?.visible) {
          const tt = clock.elapsedTime
          const p = giftSparkleRig.positions
          for (let i = 0; i < giftSparkleRig.count; i++) {
            giftSparkleRig.angles[i] +=
              giftSparkleRig.speeds[i] * dt * (1 + 0.45 * intro.emitT)
            giftSparkleRig.heights[i] +=
              giftSparkleRig.rises[i] * dt * (1 + 0.65 * intro.emitT)
            if (giftSparkleRig.heights[i] > giftSparkleRig.maxH) {
              giftSparkleRig.heights[i] = giftSparkleRig.minH
              giftSparkleRig.angles[i] = Math.random() * Math.PI * 2
              giftSparkleRig.radii[i] =
                giftSparkleRig.minR +
                Math.random() * (giftSparkleRig.maxR - giftSparkleRig.minR)
            }
            const a = giftSparkleRig.angles[i]
            const r =
              giftSparkleRig.radii[i] +
              0.16 * Math.sin(tt * 1.4 + giftSparkleRig.phases[i])
            const y =
              giftSparkleRig.heights[i] +
              0.16 * Math.sin(tt * 2.35 + giftSparkleRig.phases[i])
            p[i * 3 + 0] = Math.cos(a) * r
            p[i * 3 + 1] = y
            p[i * 3 + 2] = Math.sin(a) * r
          }
          giftSparkleRig.geometry.attributes.position.needsUpdate = true
        }
        if (giftBoxGroup) {
          _introEmitFrom.set(
            giftBoxGroup.position.x,
            giftBoxGroup.position.y + 4.2 * giftBoxGroup.scale.y * 0.58,
            giftBoxGroup.position.z + 6.2 * giftBoxGroup.scale.y * 0.05
          )
        }

        if (t >= 1) {
          intro.phase = 'DONE'
          intro.emitT = 1
          if (giftBoxGroup) giftBoxGroup.visible = false
        }
      }

      function createGiftBox() {
        giftBoxMaterials = []

        const group = new THREE.Group()
        const w = 6.2
        const h = 4.2
        const d = 6.2
        const lidH = 0.62

        const hexToCss = (hex) => `#${hex.toString(16).padStart(6, '0')}`
        const makeBoxTexture = (baseHex, accentHex) => {
          const c = document.createElement('canvas')
          c.width = 512
          c.height = 512
          const ctx = c.getContext('2d')
          const base = hexToCss(baseHex)
          const accent = hexToCss(accentHex)

          const grad = ctx.createLinearGradient(40, 40, 472, 472)
          grad.addColorStop(0, base)
          grad.addColorStop(0.45, '#fff4fb')
          grad.addColorStop(1, base)
          ctx.fillStyle = grad
          ctx.fillRect(0, 0, 512, 512)

          ctx.globalAlpha = 0.22
          ctx.fillStyle = 'rgba(255,255,255,0.85)'
          for (let i = -200; i < 800; i += 52) {
            ctx.save()
            ctx.translate(i, 0)
            ctx.rotate(Math.PI / 4)
            ctx.fillRect(0, 0, 24, 900)
            ctx.restore()
          }

          const drawHeart = (x, y, s, r, a) => {
            ctx.save()
            ctx.translate(x, y)
            ctx.rotate(r)
            ctx.scale(s, s)
            ctx.globalAlpha = a
            ctx.fillStyle = accent
            ctx.beginPath()
            ctx.moveTo(0, 0.3)
            ctx.bezierCurveTo(-0.7, -0.25, -0.65, -1.05, 0, -0.72)
            ctx.bezierCurveTo(0.65, -1.05, 0.7, -0.25, 0, 0.3)
            ctx.closePath()
            ctx.fill()
            ctx.restore()
          }

          for (let yy = 40; yy < 512; yy += 74) {
            for (let xx = 34; xx < 512; xx += 86) {
              drawHeart(
                xx + (Math.random() - 0.5) * 22,
                yy + (Math.random() - 0.5) * 18,
                18 + Math.random() * 10,
                (Math.random() - 0.5) * 0.6,
                0.08 + Math.random() * 0.12
              )
            }
          }

          ctx.globalAlpha = 0.18
          ctx.strokeStyle = 'rgba(255,255,255,0.7)'
          ctx.lineWidth = 6
          ctx.strokeRect(16, 16, 480, 480)

          const tex = new THREE.CanvasTexture(c)
          tex.colorSpace = THREE.SRGBColorSpace
          tex.anisotropy = 8
          tex.needsUpdate = true
          return tex
        }

        const makeGlitterTexture = () => {
          const c = document.createElement('canvas')
          c.width = 512
          c.height = 512
          const ctx = c.getContext('2d')
          ctx.fillStyle = '#ffd48a'
          ctx.fillRect(0, 0, 512, 512)
          for (let i = 0; i < 1200; i++) {
            const x = Math.random() * 512
            const y = Math.random() * 512
            const r = Math.random() < 0.85 ? 1 : 2.2
            ctx.globalAlpha = 0.15 + Math.random() * 0.35
            ctx.fillStyle =
              Math.random() < 0.5
                ? 'rgba(255,255,255,1)'
                : 'rgba(255,238,200,1)'
            ctx.beginPath()
            ctx.arc(x, y, r, 0, Math.PI * 2)
            ctx.fill()
          }
          ctx.globalAlpha = 0.25
          const grad = ctx.createLinearGradient(0, 0, 512, 0)
          grad.addColorStop(0, 'rgba(255,255,255,0)')
          grad.addColorStop(0.5, 'rgba(255,255,255,0.35)')
          grad.addColorStop(1, 'rgba(255,255,255,0)')
          ctx.fillStyle = grad
          ctx.fillRect(0, 0, 512, 512)

          const tex = new THREE.CanvasTexture(c)
          tex.colorSpace = THREE.SRGBColorSpace
          tex.wrapS = THREE.RepeatWrapping
          tex.wrapT = THREE.RepeatWrapping
          tex.repeat.set(2, 2)
          tex.anisotropy = 8
          tex.needsUpdate = true
          return tex
        }

        const makeGlowTexture = () => {
          const c = document.createElement('canvas')
          c.width = 128
          c.height = 128
          const ctx = c.getContext('2d')
          const g = ctx.createRadialGradient(64, 64, 0, 64, 64, 64)
          g.addColorStop(0, 'rgba(255,220,180,0.9)')
          g.addColorStop(0.35, 'rgba(255,210,180,0.4)')
          g.addColorStop(0.7, 'rgba(255,120,190,0.12)')
          g.addColorStop(1, 'rgba(255,120,190,0)')
          ctx.fillStyle = g
          ctx.fillRect(0, 0, 128, 128)
          const tex = new THREE.CanvasTexture(c)
          tex.colorSpace = THREE.SRGBColorSpace
          tex.needsUpdate = true
          return tex
        }

        const boxTex = makeBoxTexture(0xff6aa6, 0xffd7b3)
        const lidTex = makeBoxTexture(0xfff0f7, 0xff6aa6)
        const glitterTex = makeGlitterTexture()

        const baseMat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          map: boxTex,
          metalness: 0.15,
          roughness: 0.26,
          clearcoat: 1.0,
          clearcoatRoughness: 0.14,
          envMapIntensity: 1.25,
          emissive: 0x2b0814,
          emissiveIntensity: 0.2,
        })
        baseMat.transparent = true
        baseMat.opacity = 1
        giftBoxMaterials.push(baseMat)

        const lidMat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          map: lidTex,
          metalness: 0.0,
          roughness: 0.72,
          clearcoat: 0.18,
          clearcoatRoughness: 0.75,
          envMapIntensity: 0.35,
          emissive: 0x12040a,
          emissiveIntensity: 0.06,
        })
        lidMat.transparent = true
        lidMat.opacity = 1
        giftBoxMaterials.push(lidMat)

        const ribbonMat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          map: glitterTex,
          metalness: 0.35,
          roughness: 0.48,
          clearcoat: 0.65,
          clearcoatRoughness: 0.55,
          envMapIntensity: 0.9,
          emissive: 0xffd8a6,
          emissiveIntensity: 0.16,
        })
        ribbonMat.transparent = true
        ribbonMat.opacity = 1
        giftBoxMaterials.push(ribbonMat)

        const base = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), baseMat)
        base.position.y = h / 2
        group.add(base)

        const edgeMat = new THREE.LineBasicMaterial({
          color: 0xfff1d6,
          transparent: true,
          opacity: 0.4,
          blending: THREE.AdditiveBlending,
        })
        edgeMat.toneMapped = false
        giftBoxMaterials.push(edgeMat)

        const baseEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(base.geometry, 35),
          edgeMat
        )
        baseEdges.position.copy(base.position)
        group.add(baseEdges)

        const ribbonX = new THREE.Mesh(new THREE.BoxGeometry(w * 0.13, h + 0.02, d + 0.04), ribbonMat)
        ribbonX.position.y = (h + 0.02) / 2
        group.add(ribbonX)

        const ribbonZ = new THREE.Mesh(new THREE.BoxGeometry(w + 0.04, h + 0.02, d * 0.13), ribbonMat)
        ribbonZ.position.y = (h + 0.02) / 2
        group.add(ribbonZ)

        const lidPivot = new THREE.Group()
        lidPivot.position.set(0, h, -d / 2)
        group.add(lidPivot)
        giftBoxLidPivot = lidPivot

        const lid = new THREE.Mesh(new THREE.BoxGeometry(w + 0.26, lidH, d + 0.26), lidMat)
        lid.position.set(0, lidH / 2, d / 2)
        lidPivot.add(lid)

        const lidEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(lid.geometry, 35),
          edgeMat
        )
        lidEdges.position.copy(lid.position)
        lidPivot.add(lidEdges)

        const lidRibbonX = new THREE.Mesh(new THREE.BoxGeometry(w * 0.13, lidH + 0.02, d + 0.3), ribbonMat)
        lidRibbonX.position.set(0, lidH / 2 + 0.01, d / 2)
        lidPivot.add(lidRibbonX)

        const lidRibbonZ = new THREE.Mesh(new THREE.BoxGeometry(w + 0.3, lidH + 0.02, d * 0.13), ribbonMat)
        lidRibbonZ.position.set(0, lidH / 2 + 0.01, d / 2)
        lidPivot.add(lidRibbonZ)

        const bowGroup = new THREE.Group()
        bowGroup.position.set(0, lidH + 0.16, d / 2)
        bowGroup.rotation.x = -0.08
        lidPivot.add(bowGroup)

        const knot = new THREE.Mesh(new THREE.SphereGeometry(0.22, 18, 12), ribbonMat)
        knot.scale.set(1.05, 0.78, 1.05)
        bowGroup.add(knot)

        const makeRibbonShape = (width, thickness) => {
          const s = new THREE.Shape()
          const w2 = width / 2
          const t2 = thickness / 2
          s.moveTo(-w2, -t2)
          s.lineTo(w2, -t2)
          s.lineTo(w2, t2)
          s.lineTo(-w2, t2)
          s.closePath()
          return s
        }

        const makeRibbonAlong = (curve, width, thickness, steps) => {
          const shape = makeRibbonShape(width, thickness)
          const geo = new THREE.ExtrudeGeometry(shape, {
            steps,
            bevelEnabled: false,
            extrudePath: curve,
          })
          const mesh = new THREE.Mesh(geo, ribbonMat)
          bowGroup.add(mesh)
        }

        const makeLoop = (dir) => {
          const pts = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0.28 * dir, 0.2, 0.05),
            new THREE.Vector3(0.92 * dir, 0.26, 0.36),
            new THREE.Vector3(1.22 * dir, 0.06, 0.0),
            new THREE.Vector3(0.92 * dir, -0.2, -0.36),
            new THREE.Vector3(0.28 * dir, -0.12, -0.05),
            new THREE.Vector3(0, 0, 0),
          ]
          const curve = new THREE.CatmullRomCurve3(pts)
          makeRibbonAlong(curve, 0.34, 0.045, 70)
        }
        makeLoop(1)
        makeLoop(-1)

        const makeTail = (dir) => {
          const pts = [
            new THREE.Vector3(0.08 * dir, -0.02, 0.12),
            new THREE.Vector3(0.28 * dir, -0.42, 0.22),
            new THREE.Vector3(0.48 * dir, -0.98, 0.12),
            new THREE.Vector3(0.34 * dir, -1.72, 0.02),
          ]
          const curve = new THREE.CatmullRomCurve3(pts)
          makeRibbonAlong(curve, 0.26, 0.04, 46)
        }
        makeTail(1)
        makeTail(-1)

        group.position.set(0, -7.2, 18)
        _giftBoxBasePos.copy(group.position)
        group.scale.setScalar(1.85)
        group.visible = true

        _introEmitFrom.set(group.position.x, group.position.y + (h * group.scale.y) * 0.88, group.position.z)

        giftBoxInnerLight = new THREE.PointLight(0xffc9ee, 0, 40)
        giftBoxInnerLight.position.set(0, h * 0.86, 0)
        group.add(giftBoxInnerLight)

        const glowTex = makeGlowTexture()
        const glowMat = new THREE.MeshBasicMaterial({
          map: glowTex,
          transparent: true,
          opacity: 0.85,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        })
        glowMat.toneMapped = false
        giftBoxMaterials.push(glowMat)
        giftBoxGlow = new THREE.Mesh(new THREE.PlaneGeometry(18, 18), glowMat)
        giftBoxGlow.position.set(0, h * 0.9, -d * 0.95)
        group.add(giftBoxGlow)

        const sparkMat = new THREE.PointsMaterial({
          map: glowTex,
          transparent: true,
          opacity: 1,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          size: 0.26,
          sizeAttenuation: true,
          vertexColors: true,
        })
        sparkMat.toneMapped = false
        giftBoxMaterials.push(sparkMat)

        const sparkCount = 220
        const positions = new Float32Array(sparkCount * 3)
        const colors = new Float32Array(sparkCount * 3)
        const angles = new Float32Array(sparkCount)
        const radii = new Float32Array(sparkCount)
        const speeds = new Float32Array(sparkCount)
        const heights = new Float32Array(sparkCount)
        const rises = new Float32Array(sparkCount)
        const phases = new Float32Array(sparkCount)

        const gold = new THREE.Color(0xfff1c9)
        const pink = new THREE.Color(0xff7db7)
        const white = new THREE.Color(0xffffff)
        const minR = 3.6
        const maxR = 6.4
        const minH = 0.4
        const maxH = 6.0
        for (let i = 0; i < sparkCount; i++) {
          angles[i] = Math.random() * Math.PI * 2
          radii[i] = minR + Math.random() * (maxR - minR)
          speeds[i] = 0.85 + Math.random() * 1.55
          heights[i] = minH + Math.random() * (maxH - minH)
          rises[i] = 0.35 + Math.random() * 0.75
          phases[i] = Math.random() * Math.PI * 2

          const mix = Math.random()
          const c = mix < 0.5 ? gold : mix < 0.82 ? pink : white
          const f = 0.65 + Math.random() * 0.55
          colors[i * 3 + 0] = c.r * f
          colors[i * 3 + 1] = c.g * f
          colors[i * 3 + 2] = c.b * f
        }

        const sparkGeo = new THREE.BufferGeometry()
        sparkGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3))
        sparkGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3))
        const sparks = new THREE.Points(sparkGeo, sparkMat)
        sparks.position.set(0, h * 0.25, 0)
        group.add(sparks)

        giftSparkleRig = {
          points: sparks,
          geometry: sparkGeo,
          material: sparkMat,
          count: sparkCount,
          positions,
          angles,
          radii,
          speeds,
          heights,
          rises,
          phases,
          minR,
          maxR,
          minH,
          maxH,
        }

        giftBoxGroup = group
        mainGroup.add(group)
      }

      function createTextures() {
        const canvas = document.createElement('canvas')
        canvas.width = 128
        canvas.height = 128
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = '#ffffff'
        ctx.fillRect(0, 0, 128, 128)
        ctx.fillStyle = '#880000'
        ctx.beginPath()
        for (let i = -128; i < 256; i += 32) {
          ctx.moveTo(i, 0)
          ctx.lineTo(i + 32, 128)
          ctx.lineTo(i + 16, 128)
          ctx.lineTo(i - 16, 0)
        }
        ctx.fill()
        caneTexture = new THREE.CanvasTexture(canvas)
        caneTexture.wrapS = THREE.RepeatWrapping
        caneTexture.wrapT = THREE.RepeatWrapping
        caneTexture.repeat.set(3, 3)

        const s = document.createElement('canvas')
        s.width = 256
        s.height = 256
        const sctx = s.getContext('2d')
        sctx.clearRect(0, 0, s.width, s.height)
        sctx.translate(s.width / 2, s.height / 2)
        sctx.lineCap = 'round'
        sctx.shadowColor = 'rgba(255,255,255,0.9)'
        sctx.shadowBlur = 18
        for (let pass = 0; pass < 2; pass++) {
          sctx.strokeStyle = pass === 0 ? 'rgba(255,255,255,0.55)' : 'rgba(255,255,255,0.95)'
          sctx.lineWidth = pass === 0 ? 10 : 5
          for (let i = 0; i < 6; i++) {
            sctx.save()
            sctx.rotate((i * Math.PI) / 3)
            sctx.beginPath()
            sctx.moveTo(0, 0)
            sctx.lineTo(0, -92)
            sctx.stroke()
            for (const d of [28, 50, 72]) {
              sctx.beginPath()
              sctx.moveTo(0, -d)
              sctx.lineTo(-16, -d - 14)
              sctx.stroke()
              sctx.beginPath()
              sctx.moveTo(0, -d)
              sctx.lineTo(16, -d - 14)
              sctx.stroke()
            }
            sctx.restore()
          }
        }
        sctx.setTransform(1, 0, 0, 1, 0, 0)
        snowflakeTexture = new THREE.CanvasTexture(s)
        snowflakeTexture.colorSpace = THREE.SRGBColorSpace
        snowflakeTexture.anisotropy = 8
        snowflakeTexture.needsUpdate = true
      }

      class SnowflakeInstancedSystem {
        constructor(count) {
          this.count = count
          this.items = new Array(count)
          this.mesh = null
          this._tmpMatrix = new THREE.Matrix4()
          this._tmpPos = new THREE.Vector3()
          this._tmpScale = new THREE.Vector3()
          this._tmpQuat = new THREE.Quaternion()
          this._tmpQuatZ = new THREE.Quaternion()
          this._tmpColor = new THREE.Color()
          this._zAxis = new THREE.Vector3(0, 0, 1)
          this._baseQuat = new THREE.Quaternion()
        }

        init() {
          const geo = new THREE.CircleGeometry(0.108, 10)
          const mat = new THREE.MeshPhysicalMaterial(STAR_MATERIAL_PARAMS)
          mat.transparent = true
          mat.opacity = 0.95
          mat.depthWrite = false
          mat.depthTest = true
          mat.side = THREE.DoubleSide
          mat.toneMapped = false
          this.mesh = new THREE.InstancedMesh(geo, mat, this.count)
          this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage)
          this.mesh.frustumCulled = false

          const h = CONFIG.particles.treeHeight
          const halfH = h / 2

          for (let i = 0; i < this.count; i++) {
            let t = Math.pow(Math.random(), 1.6)
            t = Math.min(t, 0.96)
            const y = t * h - halfH + (Math.random() - 0.5) * 0.65
            let rMax = CONFIG.particles.treeRadius * (1.0 - t)
            if (rMax < 0.5) rMax = 0.5
            const angle = t * 50 * Math.PI + Math.random() * Math.PI
            const r = rMax * (1.0 + Math.random() * 0.2)

            const posTree = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r)

            const rScatter = 8 + Math.random() * 12
            const theta = Math.random() * Math.PI * 2
            const phi = Math.acos(2 * Math.random() - 1)
            const posScatter = new THREE.Vector3(
              rScatter * Math.sin(phi) * Math.cos(theta),
              rScatter * Math.sin(phi) * Math.sin(theta),
              rScatter * Math.cos(phi)
            )

            let baseScale = 0.16 + Math.random() * 0.44
            if (Math.random() < 0.012) baseScale *= 1.6 + Math.random() * 0.8
            const spinZ = (Math.random() - 0.5) * 2.2
            let ex = Math.random() - 0.5
            let ey = Math.random() - 0.2
            let ez = Math.random() - 0.5
            const el = Math.hypot(ex, ey, ez) || 1
            ex /= el
            ey /= el
            ez /= el
            const emitAmp = 16.0 + Math.random() * 22.0
            const emitDelay = Math.random() * 0.34
            const emitPhase = Math.random() * Math.PI * 2

            this.items[i] = {
              pos: posTree.clone(),
              posTree,
              posScatter,
              zRot: Math.random() * Math.PI * 2,
              spinZ,
              baseScale,
              emitX: ex,
              emitY: ey,
              emitZ: ez,
              emitAmp,
              emitDelay,
              emitPhase,
            }
          }

          this.update(0.016, 'TREE')
        }

        update(dt, mode) {
          if (!this.mesh) return
          const intro = STATE.intro
          const introActive = !!intro && intro.phase !== 'DONE' && intro.emitT > 0
          const introT = introActive ? intro.emitT : 0
          const h = CONFIG.particles.treeHeight
          const halfH = h / 2
          const useScatter = !introActive && (mode === 'SCATTER' || mode === 'FOCUS')
          const lerpSpeed = mode === 'FOCUS' ? 2.6 : 2.1
          this._baseQuat.copy(mainGroup.quaternion).invert().multiply(camera.quaternion)

          for (let i = 0; i < this.count; i++) {
            const it = this.items[i]
            const target = useScatter ? it.posScatter : it.posTree
            if (introActive) {
              const u = clamp01((introT - it.emitDelay * 0.65) / 0.86)
              const tt = easeInOutCubic(u)
              const curl = (1 - u) * it.emitAmp
              const spin =
                it.emitPhase + (1 - u) * 12.8 + clock.elapsedTime * 0.95 * (1 - u)
              const s = Math.sin(Math.PI * u)
              const a = s * curl * 1.55
              it.pos.set(
                THREE.MathUtils.lerp(_introEmitFrom.x, it.posTree.x, tt) +
                  it.emitX * a +
                  Math.cos(spin) * curl * 0.52 * s,
                THREE.MathUtils.lerp(_introEmitFrom.y, it.posTree.y, tt) +
                  it.emitY * a +
                  (1 - u) * curl * 0.3 * s,
                THREE.MathUtils.lerp(_introEmitFrom.z, it.posTree.z, tt) +
                  it.emitZ * a +
                  Math.sin(spin) * curl * 0.52 * s
              )
            } else {
              it.pos.lerp(target, lerpSpeed * dt)
            }

            if (useScatter) it.zRot += it.spinZ * dt
            else it.zRot += 0.35 * dt

            const tn = THREE.MathUtils.clamp((it.pos.y + halfH) / h, 0, 1)
            const glowScale = THREE.MathUtils.lerp(1.35, 0.6, tn)
            const scaleIn = introActive ? smoothstep(0.0, 0.22, introT - it.emitDelay) : 1

            this._tmpPos.copy(it.pos)
            this._tmpScale.setScalar(it.baseScale * glowScale * scaleIn)

            this._tmpQuat.copy(this._baseQuat)
            this._tmpQuatZ.setFromAxisAngle(this._zAxis, it.zRot)
            this._tmpQuat.multiply(this._tmpQuatZ)

            this._tmpMatrix.compose(this._tmpPos, this._tmpQuat, this._tmpScale)
            this.mesh.setMatrixAt(i, this._tmpMatrix)
          }

          this.mesh.instanceMatrix.needsUpdate = true
        }
      }

      class RibbonInstancedSystem {
        constructor(count) {
          this.count = count
          this.items = new Array(count)
          this.mesh = null
          this._tmpMatrix = new THREE.Matrix4()
          this._tmpPos = new THREE.Vector3()
          this._tmpScale = new THREE.Vector3()
          this._tmpQuat = new THREE.Quaternion()
          this._tmpQuatZ = new THREE.Quaternion()
          this._zAxis = new THREE.Vector3(0, 0, 1)
          this._baseQuat = new THREE.Quaternion()
          this._heartCenter = new THREE.Vector3(0, 0.6, 0)
          this._ribbonCenter = new THREE.Vector3()
          this._target = new THREE.Vector3()
          this._tmp = new THREE.Vector3()
          this._camRight = new THREE.Vector3()
          this._camUp = new THREE.Vector3()
          this._camFwd = new THREE.Vector3()
        }

        init() {
          const geo = new THREE.CircleGeometry(0.09, 10)
          const mat = new THREE.MeshPhysicalMaterial(STAR_MATERIAL_PARAMS)
          mat.transparent = true
          mat.opacity = 0.52
          mat.emissiveIntensity = 2.0
          mat.depthWrite = false
          mat.depthTest = true
          mat.side = THREE.DoubleSide
          mat.toneMapped = false

          this.mesh = new THREE.InstancedMesh(geo, mat, this.count)
          this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage)
          this.mesh.frustumCulled = false

          const h = CONFIG.particles.treeHeight
          this._ribbonCenter.set(0, -h / 2 + 0.6, 0)
          const strands = 2
          const perStrand = Math.floor(this.count / strands)

          for (let i = 0; i < this.count; i++) {
            const strand = i % strands
            const u = Math.min(Math.floor(i / strands) / Math.max(1, perStrand - 1), 1)
            const phase = Math.random() * Math.PI * 2
            const widthOffset = (Math.random() - 0.5) * 0.75
            const baseScale = 0.45 + Math.random() * 0.65
            const spinZ = (Math.random() - 0.5) * 0.9
            let ex = Math.random() - 0.5
            let ey = Math.random() - 0.2
            let ez = Math.random() - 0.5
            const el = Math.hypot(ex, ey, ez) || 1
            ex /= el
            ey /= el
            ez /= el
            const emitAmp = 12.0 + Math.random() * 18.0
            const emitDelay = 0.08 + u * 0.28 + Math.random() * 0.14
            const emitPhase = Math.random() * Math.PI * 2

            const ht = Math.random() * Math.PI * 2
            const hx0 = 16 * Math.pow(Math.sin(ht), 3)
            const hy0 =
              13 * Math.cos(ht) -
              5 * Math.cos(2 * ht) -
              2 * Math.cos(3 * ht) -
              Math.cos(4 * ht)
            const fill = Math.sqrt(Math.random())
            const hz = (Math.random() - 0.5) * 0.18
            const sx = 0.2
            const sy = 0.2
            const hx = hx0 * sx * fill + (Math.random() - 0.5) * 0.06
            const hy = hy0 * sy * fill + (Math.random() - 0.5) * 0.06

            const pos = new THREE.Vector3()
            this.items[i] = {
              pos,
              heartX: hx,
              heartY: hy,
              heartZ: hz,
              u,
              strand,
              phase,
              widthOffset,
              zRot: Math.random() * Math.PI * 2,
              spinZ,
              baseScale,
              emitX: ex,
              emitY: ey,
              emitZ: ez,
              emitAmp,
              emitDelay,
              emitPhase,
            }
          }

          this.update(0.016, 'TREE')
        }

        update(dt, mode) {
          if (!this.mesh) return
          const t = clock.elapsedTime
          const intro = STATE.intro
          const introActive = !!intro && intro.phase !== 'DONE' && intro.emitT > 0
          const introT = introActive ? intro.emitT : 0
          const useHeart = !introActive && (mode === 'SCATTER' || mode === 'FOCUS')
          const lerpSpeed = useHeart ? 3.4 : 2.2
          this._baseQuat.copy(mainGroup.quaternion).invert().multiply(camera.quaternion)

          const h = CONFIG.particles.treeHeight
          const halfH = h / 2
          
          const mat = this.mesh.material
          if (useHeart) {
            mat.opacity = 0.72
            mat.emissiveIntensity = 2.0
          } else {
            mat.opacity = 0.72
            mat.emissiveIntensity = 2.0
          }
          
          if (useHeart) {
            this._camRight.set(1, 0, 0).applyQuaternion(this._baseQuat)
            this._camUp.set(0, 1, 0).applyQuaternion(this._baseQuat)
            this._camFwd.set(0, 0, 1).applyQuaternion(this._baseQuat)
          }

          for (let i = 0; i < this.count; i++) {
            const it = this.items[i]

            if (useHeart) {
              this._target.copy(this._heartCenter)
              this._target.addScaledVector(this._camRight, it.heartX)
              this._target.addScaledVector(this._camUp, it.heartY)
              this._target.addScaledVector(this._camFwd, it.heartZ)
            } else {
              const u = it.u
              const turns = 1.28
              const phaseShift = it.strand === 0 ? 0 : Math.PI

              const yStart = it.strand === 0 ? -halfH + 3.0 : -halfH + h * 0.28
              const yEnd = it.strand === 0 ? -halfH + h * 0.62 : halfH - 4.0
              const yBase = THREE.MathUtils.lerp(yStart, yEnd, u)
              const y = yBase + 0.35 * Math.sin(t * 0.7 + it.phase)

              const tn = THREE.MathUtils.clamp((y + halfH) / h, 0, 1)
              let surfaceR = CONFIG.particles.treeRadius * (1.0 - tn)
              if (surfaceR < 0.5) surfaceR = 0.5

              const a =
                u * turns * Math.PI * 2 +
                phaseShift +
                t * 0.12 +
                0.12 * Math.sin(t * 0.55 + it.phase)
              const r =
                surfaceR +
                2.8 +
                it.widthOffset +
                0.35 * Math.sin(t * 0.6 + it.phase * 1.3)

              this._target.set(Math.cos(a) * r, y, Math.sin(a) * r)
            }

            if (introActive) {
              const u = clamp01((introT - it.emitDelay * 0.65) / 0.86)
              const tt = easeInOutCubic(u)
              const curl = (1 - u) * it.emitAmp
              const spin =
                it.emitPhase + (1 - u) * 14.2 + clock.elapsedTime * 0.9 * (1 - u)
              const s = Math.sin(Math.PI * u)
              const a = s * curl * 1.52
              it.pos.set(
                THREE.MathUtils.lerp(_introEmitFrom.x, this._target.x, tt) +
                  it.emitX * a +
                  Math.cos(spin) * curl * 0.48 * s,
                THREE.MathUtils.lerp(_introEmitFrom.y, this._target.y, tt) +
                  it.emitY * a +
                  (1 - u) * curl * 0.34 * s,
                THREE.MathUtils.lerp(_introEmitFrom.z, this._target.z, tt) +
                  it.emitZ * a +
                  Math.sin(spin) * curl * 0.48 * s
              )
            } else {
              it.pos.lerp(this._target, lerpSpeed * dt)
            }

            it.zRot += it.spinZ * dt

            const pulse = useHeart
              ? 1 + 0.05 * Math.sin(t * 2.0 + it.phase)
              : 1 + 0.06 * Math.sin(t * 1.2 + it.phase)
            const scaleBoost = useHeart ? 1.18 : 1.0
            const scaleIn = introActive ? smoothstep(0.0, 0.22, introT - it.emitDelay) : 1

            this._tmpPos.copy(it.pos)
            this._tmpScale.setScalar(it.baseScale * pulse * scaleBoost * scaleIn)

            this._tmpQuat.copy(this._baseQuat)
            this._tmpQuatZ.setFromAxisAngle(this._zAxis, it.zRot)
            this._tmpQuat.multiply(this._tmpQuatZ)

            this._tmpMatrix.compose(this._tmpPos, this._tmpQuat, this._tmpScale)
            this.mesh.setMatrixAt(i, this._tmpMatrix)
          }

          this.mesh.instanceMatrix.needsUpdate = true
        }
      }

      class Particle {
        constructor(mesh, type, isDust = false) {
          this.mesh = mesh
          this.type = type
          this.isDust = isDust

          this.posTree = new THREE.Vector3()
          this.posScatter = new THREE.Vector3()
          this.baseScale = mesh.scale.x
          this._tmpNormal = new THREE.Vector3()
          this._tmpUp = new THREE.Vector3()
          this._tmpRight = new THREE.Vector3()
          this._tmpMatrix = new THREE.Matrix4()
          this._tmpQuat = new THREE.Quaternion()

          // Individual Spin Speed
          // Photos spin slower to be readable
          const speedMult = type === 'PHOTO' ? 0.3 : 2.0

          this.spinSpeed = new THREE.Vector3(
            (Math.random() - 0.5) * speedMult,
            (Math.random() - 0.5) * speedMult,
            (Math.random() - 0.5) * speedMult
          )
          this._tmpIntro = new THREE.Vector3()
          {
            let ex = Math.random() - 0.5
            let ey = Math.random() - 0.2
            let ez = Math.random() - 0.5
            const el = Math.hypot(ex, ey, ez) || 1
            ex /= el
            ey /= el
            ez /= el
            this.emitDir = new THREE.Vector3(ex, ey, ez)
          }
          this.emitPhase = Math.random() * Math.PI * 2
          const ampBase = type === 'PHOTO' ? 6.2 : isDust ? 8.2 : 9.6
          this.emitAmp = ampBase * (0.85 + Math.random() * 1.0)
          this.emitDelay = 0.12

          this.calculatePositions()
        }

        calculatePositions() {
          // TREE: Tight Spiral
          const h = CONFIG.particles.treeHeight
          const halfH = h / 2
          let t = Math.random()
          if (this.type === 'GOLD_SPHERE' || this.type === 'RED' || this.type === 'CANE') {
            t = Math.pow(t, 1.8)
            t = Math.min(t, 0.96)
          } else if (this.type === 'PHOTO') {
            t = Math.pow(t, 0.8)
            t = Math.min(t, 0.96)
          } else {
            t = Math.pow(t, 1.15)
            t = Math.min(t, 0.96)
          }
          this.emitDelay = Math.min(
            0.46,
            0.05 + t * 0.35 + (this.type === 'PHOTO' ? 0.1 : 0) + Math.random() * 0.08
          )
          const y = t * h - halfH
          let rMax = CONFIG.particles.treeRadius * (1.0 - t)
          if (rMax < 0.5) rMax = 0.5
          const angle = t * 50 * Math.PI + Math.random() * Math.PI
          const r = rMax * (0.8 + Math.random() * 0.4)
          this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r)

          // SCATTER: 3D Sphere
          if (this.type === 'PHOTO') {
            this.posScatter.set(0, 1.5, 14)
            return
          }

          let rScatter = this.isDust
            ? 12 + Math.random() * 20
            : 8 + Math.random() * 12
          const theta = Math.random() * Math.PI * 2
          const phi = Math.acos(2 * Math.random() - 1)
          this.posScatter.set(
            rScatter * Math.sin(phi) * Math.cos(theta),
            rScatter * Math.sin(phi) * Math.sin(theta),
            rScatter * Math.cos(phi)
          )
        }

        update(dt, mode, focusTargetMesh) {
          const intro = STATE.intro
          const introActive = !!intro && intro.phase !== 'DONE' && intro.emitT > 0
          const introT = introActive ? intro.emitT : 0
          const activeMode = introActive ? 'TREE' : mode
          let target = this.posTree

          if (activeMode === 'SCATTER') target = this.posScatter
          else if (activeMode === 'FOCUS') {
            if (this.mesh === focusTargetMesh) {
              const desiredWorldPos = new THREE.Vector3(0, 2, 35)
              const invMatrix = new THREE.Matrix4()
                .copy(mainGroup.matrixWorld)
                .invert()
              target = desiredWorldPos.applyMatrix4(invMatrix)
            } else {
              target = this.posScatter
            }
          }

          // Movement Easing
          const lerpSpeed =
            activeMode === 'FOCUS' && this.mesh === focusTargetMesh
              ? 5.0
              : activeMode === 'SCATTER' && this.type === 'PHOTO'
                ? 3.2
                : 2.0
          if (introActive) {
            const u = clamp01((introT - this.emitDelay * 0.6) / 0.86)
            const tt = easeInOutCubic(u)
            const curl = (1 - u) * this.emitAmp
            const spin =
              this.emitPhase + (1 - u) * 15.5 + clock.elapsedTime * 0.9 * (1 - u)
            const s = Math.sin(Math.PI * u)
            const a = s * curl * 1.55
            this._tmpIntro.set(
              THREE.MathUtils.lerp(_introEmitFrom.x, this.posTree.x, tt) +
                Math.cos(spin) * curl * 0.48 * s,
              THREE.MathUtils.lerp(_introEmitFrom.y, this.posTree.y, tt) +
                (1 - u) * curl * 0.38 * s,
              THREE.MathUtils.lerp(_introEmitFrom.z, this.posTree.z, tt) +
                Math.sin(spin) * curl * 0.48 * s
            )
            this._tmpIntro.addScaledVector(this.emitDir, a * 1.1)
            this.mesh.position.copy(this._tmpIntro)
          } else {
            this.mesh.position.lerp(target, lerpSpeed * dt)
          }

          // Rotation Logic - CRITICAL: Ensure spin happens in Scatter
          if (activeMode === 'SCATTER') {
            if (this.type === 'PHOTO') {
              this.mesh.lookAt(camera.position)
            } else {
              this.mesh.rotation.x += this.spinSpeed.x * dt
              this.mesh.rotation.y += this.spinSpeed.y * dt
              this.mesh.rotation.z += this.spinSpeed.z * dt // Added Z for more natural tumble
            }
          } else if (activeMode === 'TREE') {
            if (this.type === 'PHOTO') {
              const px = this.mesh.position.x
              const pz = this.mesh.position.z
              const len = Math.hypot(px, pz)
              const cosA = len > 1e-5 ? px / len : 1
              const sinA = len > 1e-5 ? pz / len : 0

              const k = CONFIG.particles.treeRadius / CONFIG.particles.treeHeight
              this._tmpNormal.set(cosA, k, sinA).normalize()

              this._tmpUp.set(0, 1, 0)
              const dotUp = this._tmpUp.dot(this._tmpNormal)
              this._tmpUp.addScaledVector(this._tmpNormal, -dotUp)
              if (this._tmpUp.lengthSq() < 1e-6) {
                this._tmpUp.set(1, 0, 0)
                const dotAlt = this._tmpUp.dot(this._tmpNormal)
                this._tmpUp.addScaledVector(this._tmpNormal, -dotAlt)
              }
              this._tmpUp.normalize()

              this._tmpRight.crossVectors(this._tmpUp, this._tmpNormal).normalize()
              this._tmpMatrix.makeBasis(this._tmpRight, this._tmpUp, this._tmpNormal)
              this._tmpQuat.setFromRotationMatrix(this._tmpMatrix)
              this.mesh.quaternion.slerp(this._tmpQuat, 6.0 * dt)
            } else {
              this.mesh.rotation.x = THREE.MathUtils.lerp(
                this.mesh.rotation.x,
                0,
                dt
              )
              this.mesh.rotation.z = THREE.MathUtils.lerp(
                this.mesh.rotation.z,
                0,
                dt
              )
              this.mesh.rotation.y += 0.5 * dt
            }
          }

          if (activeMode === 'FOCUS' && this.mesh === focusTargetMesh) {
            this.mesh.lookAt(camera.position)
          }

          // Scale Logic
          let s = this.baseScale
          if (this.isDust) {
            s =
              this.baseScale *
              (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id))
            if (activeMode === 'TREE' && !introActive) s = 0
          } else if (activeMode === 'SCATTER' && this.type === 'PHOTO') {
            // Large preview size in scatter
            s = this.baseScale * 2.5
          } else if (activeMode === 'FOCUS') {
            if (this.mesh === focusTargetMesh) s = 4.5
            else if (this.type === 'PHOTO') s = this.baseScale * 2.5
            else s = this.baseScale
          }

          if (introActive) {
            const scaleIn = smoothstep(0.0, 0.22, introT - this.emitDelay)
            this.mesh.scale.setScalar(s * scaleIn)
          } else {
            this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt)
          }
        }
      }

      // --- CREATION ---
      function createParticles() {
        const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32)
        const curve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, -0.5, 0),
          new THREE.Vector3(0, 0.3, 0),
          new THREE.Vector3(0.1, 0.5, 0),
          new THREE.Vector3(0.3, 0.4, 0),
        ])
        const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false)

        const goldMat = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.champagneGold,
          metalness: 1.0,
          roughness: 0.1,
          envMapIntensity: 2.0,
          emissive: 0x443300,
          emissiveIntensity: 0.3,
        })

        const redMat = new THREE.MeshPhysicalMaterial({
          color: CONFIG.colors.accentRed,
          metalness: 0.3,
          roughness: 0.2,
          clearcoat: 1.0,
          emissive: 0x330000,
        })

        const candyMat = new THREE.MeshStandardMaterial({
          map: caneTexture,
          roughness: 0.4,
        })

        let snowflakeCount = 0

        for (let i = 0; i < CONFIG.particles.count; i++) {
          const rand = Math.random()
          let mesh, type

          if (rand < 0.865) {
            snowflakeCount++
            continue
          } else if (rand < 0.92) {
            mesh = new THREE.Mesh(sphereGeo, goldMat)
            type = 'GOLD_SPHERE'
          } else if (rand < 0.97) {
            mesh = new THREE.Mesh(sphereGeo, redMat)
            type = 'RED'
          } else {
            mesh = new THREE.Mesh(candyGeo, candyMat)
            type = 'CANE'
          }

          const s = 0.4 + Math.random() * 0.5
          mesh.scale.set(s, s, s)
          mesh.rotation.set(
            Math.random() * 6,
            Math.random() * 6,
            Math.random() * 6
          )

          mainGroup.add(mesh)
          particleSystem.push(new Particle(mesh, type, false))
        }

        if (snowflakeCount > 0) {
          snowflakeSystem = new SnowflakeInstancedSystem(snowflakeCount * 5)
          snowflakeSystem.init()
          mainGroup.add(snowflakeSystem.mesh)
        } else {
          snowflakeSystem = null
        }

        const points = 5
        const outerR = 1.35
        const innerR = 0.6
        const starShape = new THREE.Shape()
        for (let i = 0; i < points * 2; i++) {
          const r = i % 2 === 0 ? outerR : innerR
          const a = -Math.PI / 2 + (i * Math.PI) / points
          const x = Math.cos(a) * r
          const y = Math.sin(a) * r
          if (i === 0) starShape.moveTo(x, y)
          else starShape.lineTo(x, y)
        }
        starShape.closePath()

        const starGeo = new THREE.ExtrudeGeometry(starShape, {
          depth: 0.38,
          steps: 1,
          curveSegments: 24,
          bevelEnabled: true,
          bevelThickness: 0.14,
          bevelSize: 0.12,
          bevelOffset: 0,
          bevelSegments: 10,
        })
        starGeo.center()
        starGeo.computeVertexNormals()

        const starMat = new THREE.MeshPhysicalMaterial(STAR_MATERIAL_PARAMS)
        starMat.toneMapped = false
        starMat.transparent = true
        starMat.opacity = 1.0
        const star = new THREE.Mesh(starGeo, starMat)
        star.rotation.y = Math.PI * 0.12

        star.rotation.z = Math.PI

        const flakeMat = new THREE.MeshPhysicalMaterial(STAR_MATERIAL_PARAMS)
        flakeMat.transparent = true
        flakeMat.opacity = 0.0
        flakeMat.depthWrite = false
        flakeMat.depthTest = true
        flakeMat.side = THREE.DoubleSide
        flakeMat.toneMapped = false
        const flake = new THREE.Mesh(new THREE.CircleGeometry(0.108, 10), flakeMat)
        flake.scale.setScalar(0.9)

        const starGroup = new THREE.Group()
        starGroup.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0)
        starGroup.add(star)
        starGroup.add(flake)
        mainGroup.add(starGroup)

        {
          const rScatter = 8 + Math.random() * 12
          const theta = Math.random() * Math.PI * 2
          const phi = Math.acos(2 * Math.random() - 1)
          starRig = {
            group: starGroup,
            star,
            flake,
            morph: 0,
            zRot: Math.random() * Math.PI * 2,
            scatterPos: new THREE.Vector3(
              rScatter * Math.sin(phi) * Math.cos(theta),
              rScatter * Math.sin(phi) * Math.sin(theta),
              rScatter * Math.cos(phi)
            ),
          }
        }

        mainGroup.add(photoMeshGroup)
      }

      function createRibbon() {
        ribbonSystem = new RibbonInstancedSystem(1600)
        ribbonSystem.init()
        mainGroup.add(ribbonSystem.mesh)
      }

      const _starTreePos = new THREE.Vector3()
      const _starQuat = new THREE.Quaternion()
      const _starQuatZ = new THREE.Quaternion()
      const _starZAxis = new THREE.Vector3(0, 0, 1)

      function updateStar(dt, mode) {
        if (!starRig) return
        if (STATE.intro && STATE.intro.phase !== 'DONE') {
          if (STATE.intro.emitT < 0.88) {
            starRig.group.visible = false
            return
          }
          starRig.group.visible = true
        }
        const useScatter = mode === 'SCATTER' || mode === 'FOCUS'
        const targetMorph = useScatter ? 1 : 0
        starRig.morph += (targetMorph - starRig.morph) * 2.8 * dt
        starRig.morph = THREE.MathUtils.clamp(starRig.morph, 0, 1)

        _starTreePos.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0)
        const targetPos = useScatter ? starRig.scatterPos : _starTreePos
        starRig.group.position.lerp(targetPos, 2.2 * dt)

        starRig.star.material.opacity = 1 - starRig.morph
        starRig.flake.material.opacity = starRig.morph

        starRig.star.scale.setScalar(1 - 0.4 * starRig.morph)
        starRig.flake.scale.setScalar(0.24 + 0.44 * starRig.morph)

        starRig.zRot += 1.1 * dt
        _starQuat.copy(mainGroup.quaternion).invert().multiply(camera.quaternion)
        _starQuatZ.setFromAxisAngle(_starZAxis, starRig.zRot)
        _starQuat.multiply(_starQuatZ)
        starRig.flake.quaternion.copy(_starQuat)
      }

      function createDust() {
        const geo = new THREE.TetrahedronGeometry(0.08, 0)
        const mat = new THREE.MeshBasicMaterial({
          color: 0xffeebb,
          transparent: true,
          opacity: 0.8,
        })

        for (let i = 0; i < CONFIG.particles.dustCount; i++) {
          const mesh = new THREE.Mesh(geo, mat)
          mesh.scale.setScalar(0.5 + Math.random())
          mainGroup.add(mesh)
          particleSystem.push(new Particle(mesh, 'DUST', true))
        }
      }

      function createDefaultPhotos() {
        const canvas = document.createElement('canvas')
        canvas.width = 512
        canvas.height = 512
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = '#050505'
        ctx.fillRect(0, 0, 512, 512)
        ctx.strokeStyle = '#eebb66'
        ctx.lineWidth = 15
        ctx.strokeRect(20, 20, 472, 472)
        ctx.font = '500 60px Times New Roman'
        ctx.fillStyle = '#eebb66'
        ctx.textAlign = 'center'
        ctx.fillText('To', 256, 230)
        ctx.fillText('GN~', 256, 300)

        const tex = new THREE.CanvasTexture(canvas)
        tex.colorSpace = THREE.SRGBColorSpace
        addPhotoToScene(tex)
        relayoutScatterPhotos()
      }

      function relayoutScatterPhotos() {
        const photos = particleSystem.filter((p) => p.type === 'PHOTO')
        const n = photos.length
        if (!n) return

        const vp = getViewportProfile()
        const centerY = vp.portrait ? 1.2 : 1.5
        const baseDist = vp.portrait ? 12 : 14
        const dist = Math.max(baseDist, (vp.portrait ? 9 : 10) + n * (vp.portrait ? 0.34 : 0.45))
        const levels = Math.min(vp.portrait ? 3 : 4, Math.max(2, Math.ceil(n / (vp.portrait ? 12 : 10))))
        const span = Math.min(vp.portrait ? 3.9 : 4.8, dist * (vp.portrait ? 0.28 : 0.33))

        const yLevels = []
        if (levels === 1) yLevels.push(0)
        else {
          for (let i = 0; i < levels; i++) {
            yLevels.push(((i / (levels - 1)) * 2 - 1) * span)
          }
        }

        const buckets = Array.from({ length: levels }, () => [])
        for (let i = 0; i < n; i++) buckets[i % levels].push(photos[i])

        for (let l = 0; l < levels; l++) {
          const bucket = buckets[l]
          const m = bucket.length
          if (!m) continue
          const y = yLevels[l] ?? 0
          const r = Math.sqrt(Math.max(0.01, dist * dist - y * y))
          const rx = vp.portrait ? r * 0.72 : r
          const rz = vp.portrait ? r * 0.98 : r
          const offset = (l / levels) * (Math.PI / 3)
          for (let j = 0; j < m; j++) {
            const a = (j / m) * Math.PI * 2 + offset
            bucket[j].posScatter.set(
              Math.cos(a) * rx,
              centerY + y,
              Math.sin(a) * rz
            )
          }
        }
      }

      function addPhotoToScene(texture, opts = null) {
        const img = texture?.image ?? texture?.source?.data
        const iw = img?.naturalWidth ?? img?.videoWidth ?? img?.width ?? 0
        const ih = img?.naturalHeight ?? img?.videoHeight ?? img?.height ?? 0
        const aspect = iw > 0 && ih > 0 ? iw / ih : 1

        const maxSide = 1.18
        const photoW = aspect >= 1 ? maxSide : maxSide * aspect
        const photoH = aspect >= 1 ? maxSide / aspect : maxSide

        const border = 0.11
        const frameDepth = 0.06
        const frameGeo = new THREE.BoxGeometry(photoW + border * 2, photoH + border * 2, frameDepth)
        const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff })
        frameMat.toneMapped = false
        const frame = new THREE.Mesh(frameGeo, frameMat)

        const photoGeo = new THREE.PlaneGeometry(photoW, photoH)
        const photoMat = new THREE.MeshBasicMaterial({ map: texture, color: 0xe2e2e2 })
        photoMat.toneMapped = false
        const photo = new THREE.Mesh(photoGeo, photoMat)
        photo.position.z = frameDepth / 2 + 0.002

        const group = new THREE.Group()
        group.add(frame)
        group.add(photo)
        if (opts && typeof opts === 'object') {
          if (typeof opts.photoId === 'number') group.userData.photoId = opts.photoId
          if (typeof opts.objectUrl === 'string') group.userData.objectUrl = opts.objectUrl
        }

        const s = 0.8
        group.scale.set(s, s, s)

        photoMeshGroup.add(group)
        particleSystem.push(new Particle(group, 'PHOTO', false))
        relayoutScatterPhotos()
        if (STATE.intro && STATE.intro.phase !== 'DONE') group.visible = false
      }

      async function handleImageUpload(e) {
        const files = e.target.files
        if (!files.length) return
        const list = Array.from(files)
        e.target.value = ''
        for (const f of list) {
          try {
            const id = await savePhotoBlob(f)
            const url = URL.createObjectURL(f)
            const t = await loadTextureFromUrl(url)
            t.colorSpace = THREE.SRGBColorSpace
            addPhotoToScene(t, { photoId: id, objectUrl: url })
          } catch {}
        }
      }

      // --- MEDIAPIPE ---
      async function initMediaPipe() {
        video = document.getElementById('webcam')
        webcamCanvas = document.getElementById('webcam-preview')
        webcamCtx = webcamCanvas.getContext('2d')
        webcamCanvas.width = 160
        webcamCanvas.height = 120

        const vision = await FilesetResolver.forVisionTasks(
          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'
        )
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
            delegate: 'GPU',
          },
          runningMode: 'VIDEO',
          numHands: 1,
        })

        if (navigator.mediaDevices?.getUserMedia) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              video: { width: 640, height: 480 },
            })
            video.srcObject = stream
            video.muted = true

            // ÈáçË¶ÅÔºöÁ°Æ‰øùÊí≠ÊîæËßÜÈ¢ë
            const playPromise = video.play()
            if (playPromise !== undefined) {
              playPromise
                .then(() => {
                  console.log('Video playing successfully')
                  requestAnimationFrame(predictWebcam)
                })
                .catch((err) => {
                  console.error('Video play failed:', err)
                })
            }
          } catch (error) {
            console.error('Failed to access camera:', error)
          }
        }
      }

      let lastVideoTime = -1
      async function predictWebcam() {
        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime
          if (handLandmarker) {
            const result = handLandmarker.detectForVideo(
              video,
              performance.now()
            )
            processGestures(result)
          }
        }

        // Draw video frame to canvas
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          const cw = webcamCanvas.width
          const ch = webcamCanvas.height
          const vw = video.videoWidth || 0
          const vh = video.videoHeight || 0

          webcamCtx.setTransform(1, 0, 0, 1, 0, 0)
          webcamCtx.fillStyle = 'rgba(0, 0, 0, 1)'
          webcamCtx.fillRect(0, 0, cw, ch)

          let previewTransform = null
          if (vw > 0 && vh > 0) {
            const scale = Math.min(cw / vw, ch / vh)
            const drawW = vw * scale
            const drawH = vh * scale
            const dx = (cw - drawW) / 2
            const dy = (ch - drawH) / 2
            previewTransform = { dx, dy, scale, vw, vh }
            webcamCtx.drawImage(video, dx, dy, drawW, drawH)
          } else {
            webcamCtx.drawImage(video, 0, 0, cw, ch)
          }

          if (STATE.hand.showSkeleton && STATE.hand.landmarks) {
            drawHandSkeleton(webcamCtx, webcamCanvas, STATE.hand.landmarks, previewTransform)
          }
        }

        requestAnimationFrame(predictWebcam)
      }

      const HAND_BONES = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 4],
        [0, 5],
        [5, 6],
        [6, 7],
        [7, 8],
        [0, 9],
        [9, 10],
        [10, 11],
        [11, 12],
        [0, 13],
        [13, 14],
        [14, 15],
        [15, 16],
        [0, 17],
        [17, 18],
        [18, 19],
        [19, 20],
        [5, 9],
        [9, 13],
        [13, 17],
        [17, 5],
      ]

      function drawHandSkeleton(ctx, canvas, landmarks, transform) {
        const w = canvas.width
        const h = canvas.height
        const vw = transform?.vw ?? w
        const vh = transform?.vh ?? h
        const scale = transform?.scale ?? 1
        const dx = transform?.dx ?? 0
        const dy = transform?.dy ?? 0

        const mapX = (nx) => dx + nx * vw * scale
        const mapY = (ny) => dy + ny * vh * scale

        ctx.save()
        ctx.lineCap = 'round'
        ctx.lineJoin = 'round'
        ctx.strokeStyle = 'rgba(212, 175, 55, 0.85)'
        ctx.lineWidth = 1.6

        for (const [a, b] of HAND_BONES) {
          const la = landmarks[a]
          const lb = landmarks[b]
          if (!la || !lb) continue
          ctx.beginPath()
          ctx.moveTo(mapX(la.x), mapY(la.y))
          ctx.lineTo(mapX(lb.x), mapY(lb.y))
          ctx.stroke()
        }

        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)'
        for (let i = 0; i < landmarks.length; i++) {
          const lm = landmarks[i]
          if (!lm) continue
          const x = mapX(lm.x)
          const y = mapY(lm.y)
          ctx.beginPath()
          ctx.arc(x, y, i === 0 ? 2.4 : 1.9, 0, Math.PI * 2)
          ctx.fill()
        }

        ctx.restore()
      }

      const _pickTmpWorld = new THREE.Vector3()
      const _pickTmpCam = new THREE.Vector3()
      const _pickCamPos = new THREE.Vector3()

      function pickFrontmostPhoto() {
        const photos = particleSystem.filter((p) => p.type === 'PHOTO')
        if (!photos.length) return null

        camera.updateMatrixWorld(true)
        if (mainGroup) mainGroup.updateMatrixWorld(true)
        camera.getWorldPosition(_pickCamPos)

        let bestMesh = null
        let hasFront = false
        let bestCamZ = -Infinity
        let bestDistSq = Infinity
        for (const p of photos) {
          const m = p.mesh
          if (!m) continue
          m.getWorldPosition(_pickTmpWorld)
          _pickTmpCam.copy(_pickTmpWorld).applyMatrix4(camera.matrixWorldInverse)

          const camZ = _pickTmpCam.z
          if (camZ < 0 && camZ > bestCamZ) {
            bestCamZ = camZ
            bestMesh = m
            hasFront = true
          }

          const d2 = _pickTmpWorld.distanceToSquared(_pickCamPos)
          if (!hasFront && d2 < bestDistSq) {
            bestDistSq = d2
            bestMesh = m
          }
        }

        return bestMesh
      }

      function processGestures(result) {
        if (result.landmarks && result.landmarks.length > 0) {
          STATE.hand.detected = true
          const lm = result.landmarks[0]
          STATE.hand.landmarks = lm
          STATE.hand.lastSeenMs = performance.now()

          const palmIds = [0, 5, 9, 13, 17]
          let cx = 0
          let cy = 0
          for (const id of palmIds) {
            cx += lm[id].x
            cy += lm[id].y
          }
          cx /= palmIds.length
          cy /= palmIds.length

          const rawX = (0.5 - cx) * 2
          const rawY = (cy - 0.5) * 2
          const smooth = getGestureSensitivityConfig().smooth
          STATE.hand.x += (rawX - STATE.hand.x) * smooth
          STATE.hand.y += (rawY - STATE.hand.y) * smooth

          const thumb = lm[4]
          const index = lm[8]
          const wrist = lm[0]
          const palm = lm[9] // ÊâãÊéå‰∏≠ÂøÉ

          // ÊçèÂ§πË∑ùÁ¶ªÔºöÂ§ßÊãáÊåáÂíåÈ£üÊåá
          const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y)

          // Êè°Êã≥Ê£ÄÊµãÔºöËÆ°ÁÆóÊâÄÊúâÊâãÊåáÂ∞ñÂà∞ÊâãÊéå‰∏≠ÂøÉÁöÑË∑ùÁ¶ª
          const fingerTips = [lm[8], lm[12], lm[16], lm[20]]
          let fistDistance = 0
          fingerTips.forEach((tip) => {
            fistDistance += Math.hypot(tip.x - palm.x, tip.y - palm.y)
          })
          fistDistance /= 4

          // Âº†ÂºÄÊâãÂäøÔºöÊâãÊåáÂ∞ñÂà∞ÊâãËÖïÁöÑÂπ≥ÂùáË∑ùÁ¶ª
          const tips = [lm[8], lm[12], lm[16], lm[20]]
          let avgDist = 0
          tips.forEach(
            (t) => (avgDist += Math.hypot(t.x - wrist.x, t.y - wrist.y))
          )
          avgDist /= 4

          const now = performance.now()
          const g = STATE.gesture
          const dtMs = g.lastUpdateMs ? Math.min(80, now - g.lastUpdateMs) : 16
          g.lastUpdateMs = now

          const pinchActive = pinchDist < 0.055 && avgDist > 0.22
          const openActive = avgDist > 0.42
          const fistActive = fistDistance < 0.155 && avgDist < 0.26 && pinchDist > 0.07

          g.pinchMs = pinchActive ? Math.min(500, g.pinchMs + dtMs) : Math.max(0, g.pinchMs - dtMs * 2.2)
          g.openMs = openActive ? Math.min(500, g.openMs + dtMs) : Math.max(0, g.openMs - dtMs * 2.0)
          g.fistMs = fistActive ? Math.min(500, g.fistMs + dtMs) : Math.max(0, g.fistMs - dtMs * 2.4)

          const cooldown = now - g.lastSwitchMs < 260

          if (g.pinchMs > 90) {
            if (STATE.mode !== 'FOCUS') {
              setMode('FOCUS')
              STATE.focusTarget = pickFrontmostPhoto()
            }
          } else if (g.openMs > 120) {
            setMode('SCATTER')
          } else if (!cooldown && g.fistMs > 180 && g.pinchMs < 30) {
            setMode('TREE')
          }
        } else {
          STATE.hand.detected = false
          STATE.hand.landmarks = null
        }
      }

      function setupEvents() {
        window.addEventListener('resize', () => {
          renderer.setSize(window.innerWidth, window.innerHeight)
          if (composer) composer.setSize(window.innerWidth, window.innerHeight)
          applyResponsiveLayout()
          if (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS') relayoutScatterPhotos()
        })
        const fileInput = document.getElementById('file-input')
        fileInput.addEventListener('change', handleImageUpload)

        const settingsBtn = document.getElementById('settings-btn')
        const settingsPanel = document.getElementById('settings-panel')
        const menuUploadBtn = document.getElementById('menu-upload-btn')
        const menuManageBtn = document.getElementById('menu-manage-btn')
        const menuHideUiBtn = document.getElementById('menu-hide-ui-btn')
        const toggleSkeleton = document.getElementById('toggle-skeleton')
        const gestureSensitivity = document.getElementById('gesture-sensitivity')
        modeToggleBtn = document.getElementById('mode-toggle-btn')
        const uiLayer = document.getElementById('ui-layer')
        const webcamWrapper = document.getElementById('webcam-wrapper')
        const photoManager = document.getElementById('photo-manager')

        const closeSettings = () => settingsPanel.classList.add('hidden')
        const toggleSettings = () => settingsPanel.classList.toggle('hidden')
        const setUiHidden = (hidden) => {
          STATE.uiHidden = hidden
          if (hidden) {
            closeSettings()
            if (uiLayer) uiLayer.classList.add('ui-hidden')
            if (webcamWrapper) webcamWrapper.classList.add('ui-hidden')
          } else {
            if (uiLayer) uiLayer.classList.remove('ui-hidden')
            if (webcamWrapper) webcamWrapper.classList.remove('ui-hidden')
          }
        }

        toggleSkeleton.checked = !!STATE.hand.showSkeleton
        toggleSkeleton.addEventListener('change', () => {
          STATE.hand.showSkeleton = toggleSkeleton.checked
        })

        if (gestureSensitivity) {
          gestureSensitivity.value = STATE.gestureSensitivity || 'medium'
          gestureSensitivity.addEventListener('change', () => {
            STATE.gestureSensitivity = gestureSensitivity.value
          })
        }

        if (menuHideUiBtn) {
          menuHideUiBtn.addEventListener('click', () => setUiHidden(true))
        }

        menuUploadBtn.addEventListener('click', () => {
          closeSettings()
          fileInput.click()
        })

        menuManageBtn.addEventListener('click', () => {
          closeSettings()
          showPhotoManager()
        })

        settingsBtn.addEventListener('click', (e) => {
          e.stopPropagation()
          toggleSettings()
        })

        updateModeToggleBtn()
        if (modeToggleBtn) {
          modeToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation()
            closeSettings()
            setMode(STATE.mode === 'TREE' ? 'SCATTER' : 'TREE')
          })
        }

        settingsPanel.addEventListener('click', (e) => e.stopPropagation())

        window.addEventListener('click', () => closeSettings())

        const isUiTarget = (el) => {
          if (!(el instanceof Element)) return false
          return (
            !!el.closest('#ui-layer') ||
            !!el.closest('#settings-panel') ||
            !!el.closest('#photo-manager')
          )
        }

        const canvas = renderer.domElement
        canvas.addEventListener(
          'pointerdown',
          (e) => {
            if (STATE.uiHidden) return
            if (isUiTarget(e.target)) return
            if (STATE.drag.active || STATE.drag.tapActive) return
            if (STATE.intro && STATE.intro.phase !== 'DONE') {
              if (STATE.intro.phase === 'BOX' && pickGiftBoxAt(e.clientX, e.clientY)) {
                startIntroOpen()
              }
              e.preventDefault()
              return
            }

            closeSettings()
            if (photoManager && !photoManager.classList.contains('hidden')) return

            const hitPhoto = STATE.mode === 'SCATTER' ? pickPhotoGroupAt(e.clientX, e.clientY) : null
            if (hitPhoto) {
              STATE.drag.tapActive = true
              STATE.drag.tapPhoto = hitPhoto
              STATE.drag.pointerId = e.pointerId
              STATE.drag.startX = e.clientX
              STATE.drag.startY = e.clientY
              STATE.drag.lastX = e.clientX
              STATE.drag.lastY = e.clientY
              STATE.drag.moved = false
              STATE.drag.lastMoveMs = performance.now()
              canvas.setPointerCapture(e.pointerId)
              e.preventDefault()
              return
            }

            STATE.drag.active = true
            STATE.drag.pointerId = e.pointerId
            STATE.drag.startX = e.clientX
            STATE.drag.startY = e.clientY
            STATE.drag.lastX = e.clientX
            STATE.drag.lastY = e.clientY
            STATE.drag.moved = false
            STATE.drag.lastMoveMs = performance.now()
            STATE.drag.vx = 0
            STATE.drag.vy = 0
            canvas.setPointerCapture(e.pointerId)
            e.preventDefault()
          },
          { passive: false }
        )

        canvas.addEventListener(
          'pointermove',
          (e) => {
            if (STATE.intro && STATE.intro.phase !== 'DONE') return
            if (STATE.drag.pointerId !== e.pointerId) return
            if (!STATE.drag.active && !STATE.drag.tapActive) return

            const now = performance.now()
            const dt = Math.max(1, now - STATE.drag.lastMoveMs) / 1000

            const dx = e.clientX - STATE.drag.lastX
            const dy = e.clientY - STATE.drag.lastY
            STATE.drag.lastX = e.clientX
            STATE.drag.lastY = e.clientY
            STATE.drag.lastMoveMs = now
            STATE.drag.lastSeenMs = now
            if (!STATE.drag.moved) {
              const total = Math.abs(e.clientX - STATE.drag.startX) + Math.abs(e.clientY - STATE.drag.startY)
              if (total > 4) STATE.drag.moved = true
            }

            if (STATE.drag.tapActive) {
              if (!STATE.drag.moved) return
              STATE.drag.tapActive = false
              STATE.drag.tapPhoto = null
              STATE.drag.active = true
              STATE.drag.vx = 0
              STATE.drag.vy = 0
              STATE.drag.lastX = e.clientX
              STATE.drag.lastY = e.clientY
              STATE.drag.lastMoveMs = now
              e.preventDefault()
              return
            }

            const rotYDelta = dx * 0.006
            const rotXDelta = dy * 0.004

            STATE.rotation.y += rotYDelta
            if (STATE.mode !== 'TREE') {
              STATE.rotation.x += rotXDelta
              const maxX = Math.PI * 0.45
              STATE.rotation.x = THREE.MathUtils.clamp(STATE.rotation.x, -maxX, maxX)
            } else {
              STATE.rotation.x = 0
            }

            STATE.drag.vy = rotYDelta / dt
            STATE.drag.vx = (STATE.mode !== 'TREE' ? rotXDelta : 0) / dt

            e.preventDefault()
          },
          { passive: false }
        )

        const endDrag = (e) => {
          if (STATE.intro && STATE.intro.phase !== 'DONE') return
          if (STATE.drag.pointerId !== e.pointerId) return
          const wasActive = STATE.drag.active
          const wasTap = STATE.drag.tapActive
          const moved = STATE.drag.moved
          const tapPhoto = STATE.drag.tapPhoto

          STATE.drag.active = false
          STATE.drag.tapActive = false
          STATE.drag.tapPhoto = null
          STATE.drag.pointerId = null
          STATE.drag.lastSeenMs = performance.now()
          try {
            canvas.releasePointerCapture(e.pointerId)
          } catch {}

          const now = performance.now()
          const handActive = STATE.hand.detected || now - STATE.hand.lastSeenMs < 260
          if (!moved && !handActive) {
            if (wasTap && tapPhoto && STATE.mode === 'SCATTER') {
              setMode('FOCUS')
              STATE.focusTarget = tapPhoto
            } else if (wasActive && STATE.mode === 'FOCUS') {
              setMode('SCATTER')
            }
          }
        }

        canvas.addEventListener('pointerup', endDrag)
        canvas.addEventListener('pointercancel', endDrag)

        window.addEventListener(
          'pointerdown',
          (e) => {
            if (STATE.uiHidden) {
              setUiHidden(false)
              e.preventDefault()
              e.stopPropagation()
            }
          },
          { capture: true }
        )
          
        document
          .getElementById('close-manager')
          .addEventListener('click', hidePhotoManager)

        window.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            closeSettings()
          }
        })
      }

      // ÊòæÁ§∫ÂõæÁâáÁÆ°ÁêÜÈù¢Êùø
      function showPhotoManager() {
        updatePhotoGrid()
        document.getElementById('photo-manager').classList.remove('hidden')
      }

      // ÈöêËóèÂõæÁâáÁÆ°ÁêÜÈù¢Êùø
      function hidePhotoManager() {
        document.getElementById('photo-manager').classList.add('hidden')
      }

      // Êõ¥Êñ∞ÂõæÁâáÁΩëÊ†º
      function updatePhotoGrid() {
        const photoGrid = document.getElementById('photo-grid')
        photoGrid.innerHTML = ''
        
        // Ëé∑ÂèñÊâÄÊúâÁÖßÁâáÁ≤íÂ≠ê
        const photoParticles = particleSystem.filter(p => p.type === 'PHOTO')
        
        photoParticles.forEach((particle, index) => {
          const photoItem = document.createElement('div')
          photoItem.className = 'photo-item'
          
          // Ëé∑ÂèñÁÖßÁâáÁ∫πÁêÜ
          const photoMesh = particle.mesh.children[1];
          let imgUrl = '';
          
          if (photoMesh && photoMesh.material && photoMesh.material.map) {
            const texture = photoMesh.material.map;
            if (texture.image && texture.image.currentSrc) {
              imgUrl = texture.image.currentSrc;
            } else if (texture.image && texture.image.src) {
              imgUrl = texture.image.src;
            }
          }
          
          photoItem.innerHTML = `
            <img src="${imgUrl}" alt="Photo ${index + 1}" onerror="this.src='data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" viewBox=\"0 0 24 24\"><rect width=\"24\" height=\"24\" fill=\"%23222\"/><text x=\"12\" y=\"16\" font-family=\"Arial\" font-size=\"12\" fill=\"%23ddd\" text-anchor=\"middle\">No Image</text></svg>'">
            <div class="delete-btn" data-index="${index}">√ó</div>
          `
          photoGrid.appendChild(photoItem)
        })
        
        // Ê∑ªÂä†Âà†Èô§ÊåâÈíÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
        document.querySelectorAll('.delete-btn').forEach(btn => {
          btn.addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-index'))
            void deletePhoto(index)
          })
        })
      }

      // Âà†Èô§ÁÖßÁâá
      async function deletePhoto(index) {
        // Ëé∑ÂèñÊâÄÊúâÁÖßÁâáÁ≤íÂ≠ê
        const photoParticles = particleSystem.filter(p => p.type === 'PHOTO')
        
        if (index >= 0 && index < photoParticles.length) {
          const particleToDelete = photoParticles[index]
          const storedId = particleToDelete?.mesh?.userData?.photoId
          const storedUrl = particleToDelete?.mesh?.userData?.objectUrl
          
          // ‰ªéÂú∫ÊôØ‰∏≠ÁßªÈô§ÁΩëÊ†º
          if (particleToDelete.mesh && particleToDelete.mesh.parent) {
            particleToDelete.mesh.parent.remove(particleToDelete.mesh)
          }
          
          // ‰ªéparticleSystemÊï∞ÁªÑ‰∏≠ÁßªÈô§Á≤íÂ≠ê
          const particleIndex = particleSystem.indexOf(particleToDelete)
          if (particleIndex > -1) {
            particleSystem.splice(particleIndex, 1)
          }
          
          // ‰ªéphotoMeshGroup‰∏≠ÁßªÈô§
          if (photoMeshGroup && particleToDelete.mesh) {
            photoMeshGroup.remove(particleToDelete.mesh)
          }

          if (typeof storedId === 'number') {
            try {
              await deletePhotoBlob(storedId)
            } catch {}
          }
          if (typeof storedUrl === 'string') {
            try {
              URL.revokeObjectURL(storedUrl)
            } catch {}
          }
          
          // Êõ¥Êñ∞ÁÖßÁâáÁΩëÊ†º
          updatePhotoGrid()
          relayoutScatterPhotos()
        }
      }

      function animate() {
        requestAnimationFrame(animate)
        const dt = clock.getDelta()
        updateIntro(dt)
        const introActive = STATE.intro && STATE.intro.phase !== 'DONE'
        const mode = introActive ? 'TREE' : STATE.mode

        // Rotation Logic
        if (introActive) {
          STATE.rotation.x = 0
          STATE.rotation.y = 0
        } else {
          const nowMs = performance.now()
          const handActive = STATE.hand.detected || nowMs - STATE.hand.lastSeenMs < 260
          const hasInertia =
            Math.abs(STATE.drag.vx) + Math.abs(STATE.drag.vy) > 0.0008
          const dragActive = STATE.drag.active || hasInertia

          if (handActive) {
            STATE.drag.vx = 0
            STATE.drag.vy = 0
            const sens = getGestureSensitivityConfig()
            const rotStrength = (STATE.mode === 'TREE' ? 2.6 : 2.4) * sens.rot
            const hx = THREE.MathUtils.clamp(STATE.hand.x, -1, 1)
            const hy = THREE.MathUtils.clamp(STATE.hand.y, -1, 1)
            const targetRotY = hx * Math.PI * rotStrength
            const targetRotX =
              STATE.mode === 'TREE'
                ? 0
                : STATE.mode === 'SCATTER'
                  ? hy * Math.PI * (0.25 * rotStrength)
                  : STATE.rotation.x
            STATE.rotation.y += (targetRotY - STATE.rotation.y) * (3.0 * sens.follow) * dt
            const xFollow = (STATE.mode === 'TREE' ? 5.5 : 3.0) * sens.follow
            STATE.rotation.x += (targetRotX - STATE.rotation.x) * xFollow * dt
          } else if (dragActive) {
            if (!STATE.drag.active) {
              STATE.rotation.y += STATE.drag.vy * dt
              STATE.drag.vy *= Math.exp(-7.5 * dt)
              if (STATE.mode !== 'TREE') {
                STATE.rotation.x += STATE.drag.vx * dt
                STATE.drag.vx *= Math.exp(-7.5 * dt)
                const maxX = Math.PI * 0.45
                STATE.rotation.x = THREE.MathUtils.clamp(STATE.rotation.x, -maxX, maxX)
              } else {
                STATE.rotation.x += (0 - STATE.rotation.x) * 3.0 * dt
                STATE.drag.vx = 0
              }
            } else {
              if (STATE.mode === 'TREE') STATE.rotation.x = 0
            }
          } else {
            if (STATE.mode === 'TREE') {
              STATE.rotation.y += 0.0375 * dt
              STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt
            } else {
              STATE.rotation.y += 0.0125 * dt
            }
          }
        }

        mainGroup.rotation.y = STATE.rotation.y
        mainGroup.rotation.x = STATE.rotation.x

        if (occluder) {
          const intro = STATE.intro
          const inTreeMode = STATE.mode === 'TREE'
          const introActive = intro && intro.phase !== 'DONE'
          const showDuringIntro = introActive && (intro.emitT || 0) > 0.4
          occluder.visible = inTreeMode && (!introActive || showDuringIntro)
          if (occluder.visible) occluder.quaternion.copy(camera.quaternion)
        }

        if (snowflakeSystem) snowflakeSystem.update(dt, mode)
        if (ribbonSystem) ribbonSystem.update(dt, mode)
        updateStar(dt, mode)

        particleSystem.forEach((p) =>
          p.update(dt, mode, STATE.focusTarget)
        )
        composer.render()
      }

      init()
    </script>
  </body>
</html>
